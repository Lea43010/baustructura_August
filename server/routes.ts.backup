import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { setupLocalAuth, isAuthenticated, hashPassword, comparePasswords } from "./localAuth";
import { insertProjectSchema, insertCustomerSchema, insertCompanySchema, insertPersonSchema } from "@shared/schema";
import { z } from "zod";
import { emailService } from "./emailService";

// SFTP-Account-Erstellung f√ºr neuen Benutzer
async function createSftpAccountForUser(userId: string) {
  const sftpUsername = `baustructura_user_${userId}`;
  const sftpPassword = generateSecurePassword();
  const homeDir = `/var/ftp/user_${userId}`;
  
  // In einer echten Implementierung w√ºrde hier die PostgreSQL-Datenbank aktualisiert
  // und die Verzeichnisse auf dem Hetzner Server erstellt werden
  console.log(`SFTP-Account vorbereitet f√ºr User ${userId}:`, {
    username: sftpUsername,
    homeDir: homeDir,
    quota: "1GB"
  });
  
  // Benutzer in Bau-Structura mit SFTP-Daten aktualisieren
  await storage.updateUser(userId, {
    sftpHost: "128.140.82.20",
    sftpPort: 21,
    sftpUsername: sftpUsername,
    sftpPassword: sftpPassword,
    sftpPath: `${homeDir}/uploads/`
  });
  
  return {
    username: sftpUsername,
    password: sftpPassword,
    homeDir: homeDir
  };
}
import { emailInboxService } from "./emailInboxService";
import Stripe from "stripe";
import rateLimit from 'express-rate-limit';
import { 
  authRateLimitConfig,
  adminRateLimitConfig
} from './security';
import { registerErrorLearningRoutes } from './routes/error-learning';
import { 
  createSecurityChain, 
  validateResourceOwnership, 
  requireAdmin, 
  requireManagerOrAdmin,
  enforceUserIsolation,
  type SecurityRequest 
} from './security-middleware';
import { requireFeature, checkProjectLimit, checkCustomerLimit, getLicenseFeatures } from "./middleware/licenseMiddleware";
import { registerTrialAdminRoutes } from './admin-trial-api';
import { onLicenseActivated, onLicenseCancelled } from './sftpAutoSetup';
import { registerSftpAdminRoutes } from './routes/sftp-admin';
import { emailForwardingService } from './emailForwarding';

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('Missing required Stripe secret: STRIPE_SECRET_KEY');
}
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2025-06-30.basil",
});

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware
  await setupLocalAuth(app);

  // Direct logout route - must be registered after auth setup
  app.get("/api/logout", (req: any, res: any) => {
    req.logout((err: any) => {
      if (err) {
        console.error("Logout error:", err);
        return res.redirect('/auth?error=logout_failed');
      }
      
      // Clear session data
      req.session.destroy((sessionErr: any) => {
        if (sessionErr) {
          console.error("Session destroy error:", sessionErr);
        }
        
        // Redirect to auth page
        res.redirect('/auth?message=logged_out');
      });
    });
  });

  // Apply specific rate limiting for auth routes
  app.use('/api/auth/login', rateLimit(authRateLimitConfig));
  app.use('/api/auth/register', rateLimit(authRateLimitConfig));
  app.use('/api/auth/forgot-password', rateLimit(authRateLimitConfig));
  
  // Apply admin rate limiting
  app.use('/api/admin', rateLimit(adminRateLimitConfig));

  // Register Error Learning API routes
  registerErrorLearningRoutes(app);
  
  // Register Trial Admin API routes
  registerTrialAdminRoutes(app);
  
  // Register SFTP Admin API routes
  registerSftpAdminRoutes(app);
  
  // Import and register Chat routes
  const { chatRouter } = await import('./routes/chat');
  app.use('/', chatRouter);

  // Direkte SFTP-Einrichtung f√ºr spezifische Benutzer (Admin-Override)
  app.post("/api/admin/direct-sftp-setup", isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: 'Admin-Berechtigung erforderlich' });
      }

      const { username } = req.body;
      
      if (!username) {
        return res.status(400).json({ message: 'Username ist erforderlich' });
      }

      console.log(`üîß Admin ${req.user.email} richtet SFTP f√ºr Benutzer "${username}" ein...`);

      // Benutzer suchen
      const targetUser = await storage.getUserByEmail(`${username}@domain.com`) || 
                        await storage.getUser(username);

      if (!targetUser) {
        // Benutzer existiert nicht - Mock-Setup
        console.log(`‚ö†Ô∏è Benutzer "${username}" nicht gefunden - Mock-Setup`);
        
        const mockCredentials = {
          username: `baustructura_${username}`,
          password: `Secure${Math.random().toString(36).substring(2)}Pass!`,
          host: '128.140.82.20',
          port: 22,
          path: `/var/ftp/${username}/uploads/`,
          storageLimit: 1
        };

        // Mock E-Mail-Versand
        console.log(`üìß Mock E-Mail-Versand an ${username}@domain.com:`);
        console.log(`Host: ${mockCredentials.host}:${mockCredentials.port}`);
        console.log(`Username: ${mockCredentials.username}`);
        console.log(`Password: ${mockCredentials.password}`);
        console.log(`Path: ${mockCredentials.path}`);

        return res.json({
          success: true,
          message: `Mock SFTP-Account f√ºr "${username}" eingerichtet`,
          credentials: mockCredentials,
          note: 'Da der Benutzer nicht in der Datenbank existiert, wurde ein Mock-Setup durchgef√ºhrt'
        });
      }

      // Echter Benutzer gefunden - echte SFTP-Einrichtung
      const { SftpAutoSetup } = await import('./sftpAutoSetup');
      const result = await SftpAutoSetup.setupSftpForUser(targetUser.id, 'basic');

      if (result.success) {
        // E-Mail mit SFTP-Zugangsdaten senden
        await emailService.sendSftpWelcomeEmail({
          email: targetUser.email || `${username}@domain.com`,
          firstName: targetUser.firstName || username,
          sftpHost: result.host || '128.140.82.20',
          sftpPort: result.port || 22,
          sftpUsername: result.username,
          sftpPassword: result.password || 'TempPassword',
          sftpPath: result.path || `/var/ftp/${username}/uploads/`,
          licenseType: 'basic',
          storageLimit: 1
        });

        console.log(`‚úÖ SFTP-Account f√ºr "${username}" erfolgreich eingerichtet und E-Mail versendet`);

        res.json({
          success: true,
          message: `SFTP-Account f√ºr "${username}" erfolgreich eingerichtet`,
          credentials: {
            username: result.username,
            host: result.host,
            port: result.port,
            path: result.path
          },
          emailSent: true
        });
      } else {
        res.status(400).json({
          success: false,
          message: result.error || 'SFTP-Setup fehlgeschlagen'
        });
      }

    } catch (error) {
      console.error('Direkter SFTP-Setup Fehler:', error);
      res.status(500).json({ 
        success: false,
        message: 'Technischer Fehler bei SFTP-Einrichtung' 
      });
    }
  });

  // Note: Auth routes are now handled in localAuth.ts

  // Multer-Konfiguration f√ºr lokale Uploads
  const storage_multer = multer.diskStorage({
    destination: (req, file, cb) => {
      const userId = req.user?.id || 'anonymous';
      const uploadDir = path.join(process.cwd(), 'uploads', userId);
      
      // Verzeichnis erstellen falls nicht vorhanden
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      
      cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
      // Originaler Dateiname mit Timestamp
      const timestamp = Date.now();
      const originalName = file.originalname;
      cb(null, `${timestamp}-${originalName}`);
    }
  });

  const uploadMiddleware = multer({ 
    storage: storage_multer,
    limits: {
      fileSize: 50 * 1024 * 1024, // 50MB Limit
    }
  });

  // Standard File Upload Route
  app.post('/api/upload', isAuthenticated, uploadMiddleware.single('file'), async (req: any, res) => {
    try {
      console.log('üîÑ Upload-Request erhalten:', {
        file: req.file ? req.file.originalname : 'keine Datei',
        userId: req.user?.id,
        projectId: req.body.projectId
      });
      
      if (!req.file) {
        console.error('‚ùå Upload-Fehler: Keine Datei erhalten');
        return res.status(400).json({ message: 'Keine Datei hochgeladen' });
      }

      const userId = req.user.id;
      const projectId = req.body.projectId ? parseInt(req.body.projectId) : null;

      // Datei in Datenbank speichern
      try {
        const attachmentData = {
          fileName: req.file.originalname,
          filePath: req.file.path,
          sftpPath: `/local/uploads/${userId}/${req.file.filename}`,
          fileSize: req.file.size,
          mimeType: req.file.mimetype,
          projectId: projectId,
          uploadedBy: userId,
        };

        const attachment = await storage.createAttachment(attachmentData);
        console.log('‚úÖ Attachment in DB gespeichert:', attachment.id);

        const result = {
          id: attachment.id,
          success: true,
          fileName: req.file.originalname,
          filePath: req.file.path,
          fileSize: req.file.size,
          mimeType: req.file.mimetype,
          sftpPath: `/local/uploads/${userId}/${req.file.filename}`,
          message: 'Datei erfolgreich hochgeladen und gespeichert',
          storage: 'local'
        };

        res.json(result);
      } catch (dbError) {
        console.error('‚ùå Datenbank-Fehler beim Speichern des Attachments:', dbError);
        // Datei wurde trotzdem hochgeladen, nur DB-Eintrag fehlgeschlagen
        const result = {
          success: true,
          fileName: req.file.originalname,
          filePath: req.file.path,
          fileSize: req.file.size,
          mimeType: req.file.mimetype,
          sftpPath: `/local/uploads/${userId}/${req.file.filename}`,
          message: 'Datei hochgeladen, Datenbank-Eintrag fehlgeschlagen',
          warning: 'Datenbank-Synchronisation fehlgeschlagen',
          storage: 'local'
        };
        res.json(result);
      }
      
    } catch (error) {
      console.error('‚ùå Upload-Fehler:', error);
      res.status(500).json({ 
        success: false,
        message: 'Upload fehlgeschlagen: ' + (error instanceof Error ? error.message : 'Unbekannter Fehler')
      });
    }
  });

  // Config routes
  app.get('/api/config/maps-key', isAuthenticated, async (req, res) => {
    try {
      res.json({ 
        apiKey: process.env.GOOGLE_MAPS_API_KEY || ''
      });
    } catch (error) {
      console.error("Error fetching maps config:", error);
      res.status(500).json({ message: "Failed to fetch maps config" });
    }
  });



  // Profile routes
  app.patch('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const updateData = req.body;
      
      console.log("Profile update request:");
      console.log("  User ID:", userId);
      console.log("  Update data:", updateData);
      
      // Validate allowed fields
      const allowedFields = [
        'firstName', 'lastName', 'displayName', 'position', 'phone', 
        'location', 'timezone', 'language', 'privacyConsent', 'sftpHost', 
        'sftpPort', 'sftpUsername', 'sftpPassword', 'sftpPath', 
        'emailNotificationsEnabled'
      ];
      
      const filteredData = Object.keys(updateData)
        .filter(key => allowedFields.includes(key))
        .reduce((obj, key) => {
          obj[key] = updateData[key];
          return obj;
        }, {} as any);

      console.log("  Filtered data:", filteredData);

      if (Object.keys(filteredData).length === 0) {
        return res.status(400).json({ message: "No valid fields to update" });
      }

      const updatedUser = await storage.updateUser(userId, filteredData);
      console.log("  Update successful:", updatedUser.firstName, updatedUser.lastName);
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile", error: error.message });
    }
  });

  // Erweiterte SFTP-Test Route mit neuen Features
  app.post('/api/profile/test-sftp', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      console.log(`üß™ Testing SFTP connection for user: ${user.email}`);

      // Verwende die neue SftpAutoSetup-Klasse f√ºr den Test
      const { SftpAutoSetup } = await import('./sftpAutoSetup');
      const testResult = await SftpAutoSetup.testSftpConnection(user);

      res.json(testResult);

    } catch (error) {
      console.error("SFTP test error:", error);
      res.status(500).json({ 
        success: false, 
        message: "SFTP-Test fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // SFTP-Dateien auflisten
  app.get("/api/sftp/list/:directory?", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const directory = req.params.directory ? decodeURIComponent(req.params.directory) : '/';
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const { SftpAutoSetup } = await import('./sftpAutoSetup');
      const files = await SftpAutoSetup.listSftpFiles(user, directory);

      res.json({ success: true, files, directory, totalFiles: files.length });

    } catch (error) {
      console.error("SFTP list error:", error);
      res.status(500).json({ 
        success: false, 
        message: "SFTP-Dateiliste fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Password change endpoint
  app.post('/api/profile/change-password', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { currentPassword, newPassword } = req.body;

      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Current password and new password are required" });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ message: "New password must be at least 6 characters long" });
      }

      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Verify current password
      const isCurrentPasswordValid = await comparePasswords(currentPassword, user.password);
      if (!isCurrentPasswordValid) {
        return res.status(400).json({ message: "Current password is incorrect" });
      }

      // Hash new password
      const hashedNewPassword = await hashPassword(newPassword);
      
      // Update user password
      await storage.updateUser(userId, { password: hashedNewPassword });
      
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });

  // Profile image upload endpoint
  app.post('/api/profile/upload-image', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      // For now, we'll simulate the file upload
      // In a real implementation, you would use multer or similar for file handling
      const profileImageUrl = `/uploads/profile-images/${userId}-${Date.now()}.jpg`;
      
      // Update user with new profile image URL
      await storage.updateUser(userId, { profileImageUrl });
      
      res.json({ 
        message: "Profile image uploaded successfully",
        profileImageUrl 
      });
    } catch (error) {
      console.error("Error uploading profile image:", error);
      res.status(500).json({ message: "Failed to upload profile image" });
    }
  });

  // Project roles endpoint
  app.get('/api/profile/project-roles', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const projectRoles = await storage.getUserProjectRoles(userId);
      res.json(projectRoles);
    } catch (error) {
      console.error("Error fetching project roles:", error);
      res.status(500).json({ message: "Failed to fetch project roles" });
    }
  });



  // Attachments/Documents API endpoints
  app.get('/api/attachments', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      // Get attachments based on user role
      const attachments = user?.role === 'admin' 
        ? await storage.getAttachments()  // Admin sees all
        : await storage.getAttachmentsByUser(userId);  // User sees only theirs
      
      // Fetch projects for name mapping
      const projects = await storage.getProjects(userId);
      const projectMap = new Map(projects.map(p => [p.id, p.name]));
      
      // Drizzle returns camelCase field names automatically
      const formattedAttachments = attachments.map(attachment => ({
        id: attachment.id,
        fileName: attachment.fileName,
        filePath: attachment.filePath,
        fileSize: attachment.fileSize,
        mimeType: attachment.mimeType,
        projectId: attachment.projectId,
        projectName: attachment.projectId ? projectMap.get(attachment.projectId) : null,
        uploadedBy: attachment.uploadedBy,
        sftpPath: attachment.sftpPath,
        createdAt: attachment.createdAt,
        updatedAt: attachment.updatedAt
      }));
      
      res.json(formattedAttachments);
    } catch (error) {
      console.error("Error fetching attachments:", error);
      res.status(500).json({ message: "Failed to fetch attachments" });
    }
  });

  app.post('/api/attachments', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { fileName, filePath, fileSize, mimeType, projectId, sftpPath } = req.body;
      
      if (!fileName || !filePath) {
        return res.status(400).json({ message: "File name and path are required" });
      }

      const attachment = await storage.createAttachment({
        fileName,
        filePath,
        fileSize: fileSize || 0,
        mimeType: mimeType || 'application/octet-stream',
        projectId: projectId || null,
        uploadedBy: userId,
        sftpPath: sftpPath || null,
        sftpBackupStatus: 'completed'
      });

      res.json({ 
        success: true, 
        attachment,
        message: "Document uploaded successfully" 
      });
    } catch (error) {
      console.error("Error creating attachment:", error);
      res.status(500).json({ message: "Failed to create attachment" });
    }
  });

  // Download attachment endpoint
  app.get('/api/download/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const attachmentId = parseInt(req.params.id);
      
      // Get attachment details
      const attachment = await storage.getAttachment(attachmentId);
      if (!attachment) {
        return res.status(404).json({ message: "File not found" });
      }
      
      // Check permissions - only allow download if user owns it or is admin
      if (user?.role !== 'admin' && attachment.uploadedBy !== userId) {
        return res.status(403).json({ message: "Permission denied" });
      }
      
      // √úBERGANGSL√ñSUNG: Verwende lokalen Speicher statt SFTP
      // Pr√ºfe zuerst, ob Datei lokal existiert
      const fs = await import('fs');
      const path = await import('path');
      
      try {
        let localFilePath: string;
        
        // Verschiedene m√∂gliche lokale Pfade versuchen
        const possiblePaths = [
          attachment.filePath, // Originaler Pfad aus Datenbank
          path.join(process.cwd(), 'uploads', userId, attachment.fileName), // User-spezifischer Ordner
          path.join(process.cwd(), attachment.filePath.replace(/^\//, '')), // Relativer Pfad ohne f√ºhrenden Slash
        ];
        
        // Ersten verf√ºgbaren Pfad finden
        let fileFound = false;
        for (const testPath of possiblePaths) {
          if (fs.existsSync(testPath)) {
            localFilePath = testPath;
            fileFound = true;
            console.log(`‚úÖ Datei lokal gefunden: ${testPath}`);
            break;
          }
        }
        
        if (fileFound) {
          // Datei lokal laden und streamen
          const fileBuffer = fs.readFileSync(localFilePath);
          
          // Set appropriate headers for file streaming
          res.set({
            'Content-Type': attachment.mimeType || 'application/octet-stream',
            'Content-Disposition': `inline; filename="${attachment.fileName}"`,
            'Content-Length': fileBuffer.length.toString(),
            'Cache-Control': 'no-cache'
          });
          
          console.log(`‚úÖ Streaming lokale Datei ${attachment.fileName} (${fileBuffer.length} bytes) to browser`);
          res.send(fileBuffer);
          return;
        } else {
          throw new Error(`Datei nicht gefunden in lokalen Pfaden: ${possiblePaths.join(', ')}`);
        }
        
      } catch (localError) {
        console.error(`‚ùå Lokaler Download fehlgeschlagen f√ºr ${attachment.fileName}:`, localError.message);
        
        // Create a simple HTML page with interim solution information
        const errorHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>Datei nicht verf√ºgbar - ${attachment.fileName}</title>
            <meta charset="utf-8">
            <style>
              body { 
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
                text-align: center; 
                padding: 50px; 
                background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
                min-height: 100vh;
                margin: 0;
              }
              .container {
                background: white;
                padding: 40px;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.1);
                max-width: 500px;
                margin: 0 auto;
              }
              .error { color: #dc2626; margin: 20px 0; font-weight: 500; }
              .info { color: #059669; margin: 10px 0; }
              .tech-info { color: #6b7280; font-size: 14px; margin-top: 20px; }
              .retry-btn {
                background: #3b82f6;
                color: white;
                padding: 12px 24px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                margin-top: 20px;
                font-size: 16px;
              }
              .retry-btn:hover { background: #2563eb; }
            </style>
          </head>
          <body>
            <div class="container">
              <h2>üìÑ Datei konnte nicht ge√∂ffnet werden</h2>
              <div class="info"><strong>Datei:</strong> ${attachment.fileName}</div>
              <div class="info"><strong>Gr√∂√üe:</strong> ${Math.round(attachment.fileSize / 1024)} KB</div>
              <div class="info"><strong>Typ:</strong> ${attachment.mimeType}</div>
              <div class="error">Datei nicht verf√ºgbar</div>
              <p>Die Datei konnte nicht geladen werden. Dies kann w√§hrend der Einrichtungsphase vorkommen.</p>
              <div class="info">üí° <strong>√úbergangsl√∂sung aktiv:</strong> Dateien werden lokal gespeichert</div>
              <button class="retry-btn" onclick="window.location.reload()">Erneut versuchen</button>
              <div class="tech-info">
                Status: Lokale Speicherung<br>
                Fehler: ${localError.message}<br>
                SFTP-Server wird eingerichtet f√ºr erweiterte Funktionen
              </div>
            </div>
          </body>
          </html>
        `;
        
        res.set('Content-Type', 'text/html');
        res.send(errorHtml);
      }
    } catch (error) {
      console.error("Error downloading file:", error);
      res.status(500).json({ message: "Failed to download file" });
    }
  });

  app.delete('/api/attachments/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const attachmentId = parseInt(req.params.id);
      
      // Check if attachment exists and user has permission
      const attachment = await storage.getAttachment(attachmentId);
      if (!attachment) {
        return res.status(404).json({ message: "Document not found" });
      }
      
      // Only allow deletion if user owns it or is admin
      if (user?.role !== 'admin' && attachment.uploadedBy !== userId) {
        return res.status(403).json({ message: "Permission denied" });
      }
      
      await storage.deleteAttachment(attachmentId);
      res.json({ 
        success: true, 
        message: "Document deleted successfully" 
      });
    } catch (error) {
      console.error("Error deleting attachment:", error);
      res.status(500).json({ message: "Failed to delete attachment" });
    }
  });

  // Supabase Storage Management endpoints (replacing SFTP)
  app.get('/api/storage/files', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const projectId = req.query.projectId ? parseInt(req.query.projectId as string) : undefined;
      
      const { supabaseStorage } = await import('./supabaseStorage');
      const files = await supabaseStorage.listUserFiles(userId, projectId);
      
      res.json({
        success: true,
        files: files,
        provider: "Supabase Storage",
        path: projectId ? `projects/${projectId}` : 'general'
      });

    } catch (error) {
      console.error("Storage list files failed:", error);
      res.status(500).json({ 
        message: "Failed to list storage files", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.post('/api/storage/upload', isAuthenticated, uploadSingle, async (req: any, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "Keine Datei hochgeladen" });
      }

      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const { supabaseStorage } = await import('./supabaseStorage');
      
      // Read file buffer
      const fileBuffer = await fs.readFile(req.file.path);
      
      // Upload to Supabase Storage (with local fallback)
      const uploadResult = await supabaseStorage.uploadFile(
        userId, 
        fileBuffer, 
        req.file.originalname,
        req.body.projectId ? parseInt(req.body.projectId) : undefined
      );

      if (!uploadResult.success) {
        return res.status(500).json({
          success: false,
          message: "Upload fehlgeschlagen",
          error: uploadResult.error
        });
      }

      // Create database entry
      const attachment = await storage.createAttachment({
        fileName: req.file.originalname,
        filePath: uploadResult.filePath || req.file.path,
        externalUrl: uploadResult.url,
        mimeType: req.file.mimetype,
        fileSize: req.file.size,
        uploadedBy: userId,
        projectId: req.body.projectId ? parseInt(req.body.projectId) : null,
        storageProvider: uploadResult.url ? "supabase" : "local",
        storageStatus: "uploaded"
      });

      // Clean up local temp file
      try {
        await fs.unlink(req.file.path);
      } catch (cleanupError) {
        console.warn('Failed to cleanup temp file:', cleanupError);
      }

      console.log(`‚úÖ File uploaded successfully: ${req.file.originalname} via ${uploadResult.url ? 'Supabase' : 'Local'}`);

      res.json({
        success: true,
        message: `Datei erfolgreich hochgeladen via ${uploadResult.url ? 'Supabase Storage' : 'lokalen Speicher'}`,
        file: {
          id: attachment.id,
          name: req.file.originalname,
          size: req.file.size,
          type: req.file.mimetype,
          url: uploadResult.url,
          path: uploadResult.filePath,
          provider: uploadResult.url ? "Supabase Storage" : "Local Storage"
        }
      });

    } catch (error) {
      console.error('Storage-Upload-Fehler:', error);
      res.status(500).json({ 
        message: "Fehler beim Datei-Upload",
        error: error instanceof Error ? error.message : 'Unbekannter Fehler'
      });
    }
  });
      }
      
      const { fileName, path, fileSize } = req.body;
      
      if (!fileName) {
        return res.status(400).json({ message: "File name is required" });
      }

      // FALLBACK: Lokale Speicherung wenn SFTP fehlschl√§gt
      try {
        const SftpClient = (await import('ssh2-sftp-client')).default;
        const sftp = new SftpClient();
        
        const sftpConfig = {
          host: '128.140.82.20',
          port: 22,
          username: user.sftpUsername || `baustructura_${user.username}`,
          password: user.sftpPassword,
          connectTimeout: 5000, // 5 Sekunden Timeout
          readyTimeout: 5000
        };

        if (!sftpConfig.password) {
          throw new Error("SFTP-Zugangsdaten nicht konfiguriert");
        }

        await sftp.connect(sftpConfig);
        
        // Upload-Datei (Base64 decoded)
        const fileBuffer = Buffer.from(req.body.fileData || '', 'base64');
        const userSpecificPath = user.sftpPath || `/home/${user.email}/`;
        const uploadPath = `${userSpecificPath}${fileName}`;
        
        await sftp.put(fileBuffer, uploadPath);
        await sftp.end();

        // Erfolgreich auf SFTP hochgeladen
        const uploadResult = {
          success: true,
          fileName,
          path: uploadPath,
          size: fileBuffer.length,
          uploadedAt: new Date(),
          message: "Datei erfolgreich auf SFTP-Server hochgeladen",
          storage: 'sftp'
        };
        
        res.json(uploadResult);

      } catch (sftpError: any) {
        console.error('SFTP-Upload-Fehler:', sftpError.message);
        
        // FALLBACK: Lokale Speicherung
        try {
          const fs = await import('fs');
          const path = await import('path');
          
          // Lokales Upload-Verzeichnis erstellen
          const uploadDir = path.join(process.cwd(), 'uploads', userId);
          if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
          }
          
          // Datei lokal speichern
          const fileBuffer = Buffer.from(req.body.fileData || '', 'base64');
          const localPath = path.join(uploadDir, fileName);
          fs.writeFileSync(localPath, fileBuffer);
          
          // In Datenbank speichern
          const attachment = await storage.createAttachment({
            fileName,
            filePath: localPath,
            fileSize: fileBuffer.length,
            mimeType: req.body.mimeType || 'application/octet-stream',
            projectId: req.body.projectId || null,
            uploadedBy: userId,
            sftpPath: `/local/uploads/${userId}/${fileName}`,
            sftpBackupStatus: 'pending'
          });
          
          const fallbackResult = {
            success: true,
            fileName,
            path: localPath,
            size: fileBuffer.length,
            uploadedAt: new Date(),
            message: "Datei tempor√§r lokal gespeichert (SFTP-Server nicht verf√ºgbar)",
            storage: 'local',
            attachment
          };
          
          res.json(fallbackResult);
          
        } catch (localError: any) {
          console.error('Lokaler Upload-Fehler:', localError.message);
          res.status(500).json({
            success: false,
            message: `Upload fehlgeschlagen: ${localError.message}`,
            error: true
          });
        }
      }
    } catch (error) {
      console.error("Upload failed:", error);
      res.status(500).json({ 
        message: "Failed to upload file", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.delete('/api/sftp/files/:fileName', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role === "user") {
        return res.status(403).json({ message: "SFTP delete requires manager or admin role" });
      }
      
      const fileName = req.params.fileName;
      const path = req.query.path || user?.sftpPath || '/';
      
      // Mock delete response - in production delete the actual file via SFTP
      res.json({ 
        success: true, 
        message: `File ${fileName} deleted successfully from ${path}`,
        deletedAt: new Date()
      });
    } catch (error) {
      console.error("SFTP delete failed:", error);
      res.status(500).json({ 
        message: "Failed to delete file", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.post('/api/sftp/create-folder', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role === "user") {
        return res.status(403).json({ message: "SFTP folder creation requires manager or admin role" });
      }
      
      const { folderName, path } = req.body;
      
      if (!folderName) {
        return res.status(400).json({ message: "Folder name is required" });
      }

      // Mock folder creation response - in production create actual folder via SFTP
      res.json({ 
        success: true, 
        message: `Folder ${folderName} created successfully`,
        path: `${path || user?.sftpPath || '/'}/${folderName}`,
        createdAt: new Date()
      });
    } catch (error) {
      console.error("SFTP create folder failed:", error);
      res.status(500).json({ 
        message: "Failed to create folder", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // APPLY SMART SECURITY MIDDLEWARE THAT EXCLUDES PUBLIC ROUTES
  app.use('/api', (req, res, next) => {
    // Define public routes that should bypass security middleware
    const publicRoutes = [
      '/api/auth/login',
      '/api/auth/register', 
      '/api/auth/forgot-password',
      '/api/auth/reset-password',
      '/api/contact',
      '/api/config/maps-key'
    ];
    
    // Check if current route is public
    const fullPath = `/api${req.path}`; // Reconstruct full API path
    const isPublicRoute = publicRoutes.some(route => fullPath === route || fullPath.startsWith(route));
    
    console.log(`üîç ROUTE CHECK: ${req.path} -> ${fullPath} - isPublicRoute = ${isPublicRoute}`);
    
    if (isPublicRoute) {
      console.log(`üåê PUBLIC: Allowing public access to ${req.path}`);
      return next(); // Skip security middleware for public routes
    }
    
    // Apply security middleware for protected routes
    console.log(`üîí PROTECTED: Applying security to ${req.path}`);
    // Apply each security middleware in sequence
    const middlewares = [
      // Only apply basic authentication check for protected routes
      // The route-specific isAuthenticated middleware will handle the rest
    ];
    
    // For now, just pass through to next middleware
    // Individual route handlers will apply their own security
    return next();
  });

  // Project routes - SECURITY IMPLEMENTED
  app.get("/api/projects", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const isAdmin = user?.role === 'admin';
      
      console.log(`üîç PROJECTS ACCESS: UserID: ${userId}, Role: ${user?.role}, IsAdmin: ${isAdmin}`);
      
      const projects = await storage.getProjects(isAdmin ? undefined : userId);
      
      console.log(`‚úÖ PROJECTS LOADED: ${projects.length} projects for user ${userId}`);
      res.json(projects);
    } catch (error) {
      console.error("Error fetching projects:", error);
      res.status(404).json({ message: "Resource not found" });
    }
  });

  app.get("/api/projects/:id", isAuthenticated, async (req: any, res) => {
    try {
      const projectId = parseInt(req.params.id);
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const isAdmin = user?.role === 'admin';
      
      console.log(`üîç PROJECT ACCESS: ProjectID: ${projectId}, UserID: ${userId}, Role: ${user?.role}, IsAdmin: ${isAdmin}`);
      
      // Admin kann alle Projekte sehen, normale Benutzer nur ihre eigenen
      const project = await storage.getProject(projectId, isAdmin ? undefined : userId);
      
      if (!project) {
        console.log(`üö´ PROJECT NOT FOUND: ProjectID: ${projectId}, UserID: ${userId}`);
        return res.status(404).json({ message: "Projekt nicht gefunden" });
      }
      
      console.log(`‚úÖ PROJECT ACCESS GRANTED: ProjectID: ${projectId}, UserID: ${userId}`);
      res.json(project);
    } catch (error) {
      console.error("Error fetching project:", error);
      res.status(500).json({ message: "Interner Server-Fehler" });
    }
  });

  app.post("/api/projects", isAuthenticated, async (req: SecurityRequest, res) => {
    try {
      console.log(`üîç PROJECT CREATE REQUEST: User: ${req.user?.id}, Session: ${req.sessionID}`);
      
      if (!req.user || !req.user.id) {
        console.log(`üö´ PROJECT CREATE: No authenticated user found`);
        return res.status(401).json({ message: "Authentication required" });
      }
      
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      // Check permissions manually instead of using middleware
      if (!user || (user.role !== 'admin' && user.role !== 'manager')) {
        console.log(`üö´ PROJECT CREATE: Access denied - UserID: ${userId}, Role: ${user?.role || 'unknown'}`);
        return res.status(403).json({ message: "Insufficient permissions" });
      }

      // LIZENZ-LIMITIERUNG: Pr√ºfe Projekt-Limits basierend auf Lizenz-Typ
      const licenseFeatures = getLicenseFeatures(user.licenseType || 'basic');
      console.log(`üìä LICENSE CHECK: UserID: ${userId}, License: ${user.licenseType}, Max Projects: ${licenseFeatures.maxProjects}`);
      
      if (licenseFeatures.maxProjects !== -1) {
        const userProjects = await storage.getProjects(userId);
        if (userProjects.length >= licenseFeatures.maxProjects) {
          console.log(`üö´ PROJECT LIMIT REACHED: UserID: ${userId}, Current: ${userProjects.length}, Limit: ${licenseFeatures.maxProjects}`);
          return res.status(403).json({
            error: 'Project limit reached',
            message: `Ihr ${user.licenseType || 'Basic'} Plan erlaubt maximal ${licenseFeatures.maxProjects} Projekte. Upgraden Sie auf Professional f√ºr unbegrenzte Projekte.`,
            currentCount: userProjects.length,
            limit: licenseFeatures.maxProjects,
            upgradeRequired: 'professional',
            licenseType: user.licenseType || 'basic'
          });
        }
      }
      
      console.log(`‚úÖ PROJECT CREATE: Access granted - UserID: ${userId}, Role: ${user.role}`);
      console.log(`üìã PROJECT DATA:`, req.body);
      
      // Convert frontend data to backend schema format
      const formData = req.body;
      const convertedData = {
        name: formData.name,
        description: formData.description,
        status: formData.status || 'planning',
        // Handle date conversion properly
        startDate: formData.startDate ? new Date(formData.startDate) : null,
        endDate: formData.endDate ? new Date(formData.endDate) : null,
        // Handle budget conversion
        budget: formData.budget ? formData.budget.toString() : null,
        customerId: formData.customerId ? parseInt(formData.customerId) : null,
        // Handle location fields
        address: formData.location || formData.address,
        // User and security fields
        managerId: userId,
        userId: userId, // SECURITY: Set owner to current user
      };
      
      console.log(`üîÑ CONVERTED DATA:`, convertedData);
      
      const projectData = insertProjectSchema.parse(convertedData);
      
      const project = await storage.createProject(projectData);
      console.log(`‚úÖ PROJECT CREATED: ProjectID: ${project.id}, UserID: ${userId}`);
      res.status(201).json(project);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.log(`‚ùå PROJECT CREATE: Validation error - UserID: ${req.user?.id}`, error.errors);
        return res.status(400).json({ message: "Validierungsfehler", errors: error.errors });
      }
      console.error("Error creating project:", error);
      console.log(`üí• PROJECT CREATE ERROR: UserID: ${req.user?.id}, Error: ${error.message}`);
      res.status(500).json({ message: "Das Projekt konnte nicht erstellt werden" });
    }
  });

  // PDF Export for Projects
  app.post("/api/projects/:id/export-pdf", isAuthenticated, async (req: any, res) => {
    try {
      const projectId = parseInt(req.params.id);
      const project = await storage.getProject(projectId);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }

      const { generateFloodProtectionPDF } = await import('./pdfGenerator');
      
      // Erstelle PDF f√ºr Projekt mit angepassten Daten
      const pdfBuffer = await generateFloodProtectionPDF({
        checklist: {
          titel: `Projekt: ${project.name}`,
          typ: 'projekt', 
          status: project.status,
          erstellt_von: 'System',
          erstellt_am: project.createdAt || new Date().toISOString(),
          aufgaben_gesamt: 1,
          aufgaben_erledigt: project.completionPercentage > 50 ? 1 : 0,
          fortschritt: project.completionPercentage || 0,
          beschreibung: project.description
        },
        schieber: [],
        schaeden: [],
        wachen: [],
        exportedAt: new Date().toISOString(),
        exportedBy: 'System Export'
      });
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${project.name}_Details.pdf"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error("Error generating project PDF:", error);
      res.status(500).json({ message: "Failed to generate PDF" });
    }
  });

  app.put("/api/projects/:id", isAuthenticated, async (req: any, res) => {
    try {
      const projectId = parseInt(req.params.id);
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role === "user") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      console.log(`üîß PROJECT UPDATE: UserID: ${userId}, ProjectID: ${projectId}, Role: ${user?.role}`);
      
      const projectData = insertProjectSchema.partial().parse(req.body);
      
      // Pass userId for proper user isolation (Admin can update any project)
      const project = await storage.updateProject(
        projectId, 
        projectData, 
        user?.role === 'admin' ? undefined : userId
      );
      
      console.log(`‚úÖ PROJECT UPDATED: ${project.name} (ID: ${project.id})`);
      res.json(project);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.log(`‚ùå PROJECT UPDATE VALIDATION: UserID: ${userId}`, error.errors);
        return res.status(400).json({ message: "Invalid project data", errors: error.errors });
      }
      console.error("Error updating project:", error);
      res.status(500).json({ message: "Failed to update project" });
    }
  });

  app.delete("/api/projects/:id", isAuthenticated, async (req: any, res) => {
    try {
      const projectId = parseInt(req.params.id);
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      await storage.deleteProject(projectId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting project:", error);
      res.status(500).json({ message: "Failed to delete project" });
    }
  });

  // Customer routes
  app.get("/api/customers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      console.log("Customer fetch request:");
      console.log("User ID:", userId);
      console.log("User role:", user?.role);
      
      const customers = await storage.getCustomers();
      console.log("Found customers:", customers.length);
      
      res.json(customers);
    } catch (error) {
      console.error("Error fetching customers:", error);
      res.status(500).json({ message: "Failed to fetch customers" });
    }
  });

  app.get("/api/customers/:id", isAuthenticated, async (req: any, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const customer = await storage.getCustomer(customerId);
      
      if (!customer) {
        return res.status(404).json({ message: "Customer not found" });
      }
      
      res.json(customer);
    } catch (error) {
      console.error("Error fetching customer:", error);
      res.status(500).json({ message: "Failed to fetch customer" });
    }
  });

  app.post("/api/customers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      console.log("Customer creation request:");
      console.log("User ID:", userId);
      console.log("User role:", user?.role);
      console.log("Request body:", req.body);
      
      if (user?.role === "user") {
        return res.status(403).json({ message: "Sie haben keine ausreichende Berechtigung, bitte erstellen Sie ein Ticket" });
      }
      
      // LIZENZ-LIMITIERUNG: Pr√ºfe Kunden-Limits basierend auf Lizenz-Typ
      const licenseFeatures = getLicenseFeatures(user.licenseType || 'basic');
      console.log(`üìä LICENSE CHECK: UserID: ${userId}, License: ${user.licenseType}, Max Customers: ${licenseFeatures.maxCustomers}`);
      
      if (licenseFeatures.maxCustomers !== -1) {
        const userCustomers = await storage.getCustomers(); // Note: This gets all customers - should be filtered by userId
        const filteredCustomers = userCustomers.filter(c => c.userId === userId);
        if (filteredCustomers.length >= licenseFeatures.maxCustomers) {
          console.log(`üö´ CUSTOMER LIMIT REACHED: UserID: ${userId}, Current: ${filteredCustomers.length}, Limit: ${licenseFeatures.maxCustomers}`);
          return res.status(403).json({
            error: 'Customer limit reached',
            message: `Ihr ${user.licenseType || 'Basic'} Plan erlaubt maximal ${licenseFeatures.maxCustomers} Kunden. Upgraden Sie auf Professional f√ºr mehr Kunden.`,
            currentCount: filteredCustomers.length,
            limit: licenseFeatures.maxCustomers,
            upgradeRequired: 'professional',
            licenseType: user.licenseType || 'basic'
          });
        }
      }

      // Add user_id to customer data for user isolation
      const customerDataWithUserId = {
        ...req.body,
        userId: userId
      };
      
      const customerData = insertCustomerSchema.parse(customerDataWithUserId);
      console.log("Parsed customer data:", customerData);
      
      const customer = await storage.createCustomer(customerData);
      console.log("Created customer:", customer);
      
      res.status(201).json(customer);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Validation error:", error.errors);
        return res.status(400).json({ message: "Invalid customer data", errors: error.errors });
      }
      console.error("Error creating customer:", error);
      res.status(500).json({ message: "Failed to create customer" });
    }
  });

  app.put("/api/customers/:id", isAuthenticated, async (req: any, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role === "user") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const customerData = insertCustomerSchema.partial().parse(req.body);
      const customer = await storage.updateCustomer(customerId, customerData);
      
      res.json(customer);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid customer data", errors: error.errors });
      }
      console.error("Error updating customer:", error);
      res.status(500).json({ message: "Failed to update customer" });
    }
  });

  // Company routes
  app.get("/api/companies", isAuthenticated, async (req: any, res) => {
    try {
      const companies = await storage.getCompanies();
      res.json(companies);
    } catch (error) {
      console.error("Error fetching companies:", error);
      res.status(500).json({ message: "Failed to fetch companies" });
    }
  });

  app.get("/api/companies/:id", isAuthenticated, async (req: any, res) => {
    try {
      const companyId = parseInt(req.params.id);
      const company = await storage.getCompany(companyId);
      
      if (!company) {
        return res.status(404).json({ message: "Company not found" });
      }
      
      res.json(company);
    } catch (error) {
      console.error("Error fetching company:", error);
      res.status(500).json({ message: "Failed to fetch company" });
    }
  });

  app.post("/api/companies", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      console.log("Company creation request:");
      console.log("User ID:", userId);
      console.log("User role:", user?.role);
      console.log("Request body:", req.body);
      
      if (user?.role === "user") {
        console.log(`üö´ COMPANY CREATE: Access denied - UserID: ${userId}, Role: ${user?.role}`);
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      console.log(`‚úÖ COMPANY CREATE: Access granted - UserID: ${userId}, Role: ${user.role}`);
      
      // Add user_id to company data for user isolation
      const companyDataWithUserId = {
        ...req.body,
        userId: userId
      };
      
      const companyData = insertCompanySchema.parse(companyDataWithUserId);
      console.log("Parsed company data:", companyData);
      
      const company = await storage.createCompany(companyData);
      console.log(`‚úÖ COMPANY CREATED: CompanyID: ${company.id}, UserID: ${userId}`);
      
      res.status(201).json(company);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.log(`‚ùå COMPANY CREATE: Validation error - UserID: ${userId}`, error.errors);
        return res.status(400).json({ message: "Invalid company data", errors: error.errors });
      }
      console.error("Error creating company:", error);
      res.status(500).json({ message: "Failed to create company" });
    }
  });

  // Person routes
  app.get("/api/persons", isAuthenticated, async (req: any, res) => {
    try {
      const persons = await storage.getPersons();
      res.json(persons);
    } catch (error) {
      console.error("Error fetching persons:", error);
      res.status(500).json({ message: "Failed to fetch persons" });
    }
  });

  app.post("/api/persons", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role === "user") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const personData = insertPersonSchema.parse(req.body);
      const person = await storage.createPerson(personData);
      res.status(201).json(person);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid person data", errors: error.errors });
      }
      console.error("Error creating person:", error);
      res.status(500).json({ message: "Failed to create person" });
    }
  });

  // Attachment routes (already defined above at line 371-386)

  app.get("/api/projects/:id/attachments", isAuthenticated, async (req: any, res) => {
    try {
      const projectId = parseInt(req.params.id);
      const attachments = await storage.getAttachments(projectId);
      res.json(attachments);
    } catch (error) {
      console.error("Error fetching attachments:", error);
      res.status(500).json({ message: "Failed to fetch attachments" });
    }
  });

  // Delete route already defined above at line 419-445

  // Photo routes
  app.get("/api/projects/:id/photos", isAuthenticated, async (req: any, res) => {
    try {
      const projectId = parseInt(req.params.id);
      const photos = await storage.getPhotos(projectId);
      res.json(photos);
    } catch (error) {
      console.error("Error fetching photos:", error);
      res.status(500).json({ message: "Failed to fetch photos" });
    }
  });

  // Audio routes
  app.get("/api/projects/:id/audio", isAuthenticated, async (req: any, res) => {
    try {
      const projectId = parseInt(req.params.id);
      const audioRecords = await storage.getAudioRecords(projectId);
      res.json(audioRecords);
    } catch (error) {
      console.error("Error fetching audio records:", error);
      res.status(500).json({ message: "Failed to fetch audio records" });
    }
  });

  // Contact form route (public - no authentication required)
  app.post("/api/contact", async (req, res) => {
    try {
      const { name, email, company, subject, message } = req.body;
      
      if (!name || !email || !subject || !message) {
        return res.status(400).json({ message: "Required fields missing" });
      }

      const subjectLabels = {
        general: 'Allgemeine Fragen',
        technical: 'Technischer Support',
        sales: 'Vertrieb & Lizenzierung',
        billing: 'Abrechnung & Zahlung'
      };

      const emailData = {
        name,
        email,
        company: company || 'Nicht angegeben',
        subject: subjectLabels[subject as keyof typeof subjectLabels] || subject,
        message,
        timestamp: new Date().toISOString()
      };

      // Send contact email to support team
      try {
        await emailService.sendContactEmail(emailData);
        
        console.log('Kontaktformular-E-Mail erfolgreich versendet:', {
          from: email,
          name,
          subject: emailData.subject
        });
        
        res.json({ 
          success: true, 
          message: "Nachricht erfolgreich versendet" 
        });
      } catch (emailError) {
        console.error('Fehler beim E-Mail-Versand:', emailError);
        
        // Even if email fails, we don't want to show error to user
        // as this could be a temporary SMTP issue
        res.json({ 
          success: true, 
          message: "Nachricht erhalten - wir melden uns bei Ihnen" 
        });
      }
    } catch (error) {
      console.error("Error processing contact form:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Email inbox routes
  app.get("/api/email/inbox", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const limit = parseInt(req.query.limit as string) || 20;
      const unreadOnly = req.query.unreadOnly === 'true';
      
      const messages = await emailInboxService.getInboxMessages(limit, unreadOnly);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching inbox messages:", error);
      res.status(500).json({ message: "Failed to fetch inbox messages" });
    }
  });

  app.get("/api/email/message/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const messageId = req.params.id;
      const message = await emailInboxService.getMessageById(messageId);
      
      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }
      
      res.json(message);
    } catch (error) {
      console.error("Error fetching message:", error);
      res.status(500).json({ message: "Failed to fetch message" });
    }
  });

  app.post("/api/email/message/:id/read", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const messageId = req.params.id;
      const success = await emailInboxService.markAsRead(messageId);
      
      res.json({ success });
    } catch (error) {
      console.error("Error marking message as read:", error);
      res.status(500).json({ message: "Failed to mark message as read" });
    }
  });

  app.post("/api/email/message/:id/reply", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const messageId = req.params.id;
      const { content } = req.body;
      
      if (!content) {
        return res.status(400).json({ message: "Reply content required" });
      }
      
      const success = await emailInboxService.replyToMessage(messageId, content);
      res.json({ success });
    } catch (error) {
      console.error("Error sending reply:", error);
      res.status(500).json({ message: "Failed to send reply" });
    }
  });

  app.get("/api/email/test", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const result = await emailInboxService.testConnection();
      res.json(result);
    } catch (error) {
      console.error("Error testing email connection:", error);
      res.status(500).json({ message: "Failed to test connection" });
    }
  });

  // Support ticket routes
  app.get("/api/support-tickets", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const tickets = await storage.getSupportTickets();
      res.json(tickets);
    } catch (error) {
      console.error("Error fetching support tickets:", error);
      res.status(500).json({ message: "Failed to fetch support tickets" });
    }
  });

  // Flood PDF Export - add missing route for backward compatibility
  app.post("/api/flood-pdf-export", isAuthenticated, async (req: any, res) => {
    try {
      const { checklistData, recipientEmail } = req.body;
      
      if (!checklistData) {
        return res.status(400).json({ message: "Checklisten-Daten sind erforderlich" });
      }
      
      console.log('PDF-Export gestartet f√ºr Checkliste:', checklistData.title);
      
      // Mock data for PDF generation
      const mockData = {
        checklist: {
          titel: checklistData.title || "Test Checkliste",
          typ: "hochwasser",
          status: "offen",
          erstellt_von: req.user.firstName + " " + req.user.lastName,
          aufgaben_gesamt: 11,
          aufgaben_erledigt: 0
        },
        schieber: [],
        schaeden: [],
        wachen: [],
        exportedAt: new Date().toISOString(),
        exportedBy: req.user.firstName + " " + req.user.lastName
      };
      
      // Generate PDF using existing PDF generator
      const { generateFloodProtectionPDF } = await import('./pdfGenerator');
      
      const pdfBuffer = await generateFloodProtectionPDF(mockData);

      // Set PDF headers
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="Hochwasserschutz-Checkliste-${checklistData.title?.replace(/[^a-zA-Z0-9]/g, '-') || 'Test'}-${new Date().toISOString().split('T')[0]}.pdf"`);
      res.setHeader('Content-Length', pdfBuffer.length);
      
      console.log('PDF erfolgreich generiert, Gr√∂√üe:', pdfBuffer.length, 'bytes');
      
      // If recipientEmail is provided, could send email here
      if (recipientEmail) {
        console.log('E-Mail-Versand an:', recipientEmail, '(Implementation folgt)');
      }
      
      res.send(pdfBuffer);
      
    } catch (error) {
      console.error("Fehler beim PDF-Export:", error);
      res.status(500).json({ message: "Fehler beim PDF-Export: " + (error as Error).message });
    }
  });

  // Flood protection routes
  app.post("/api/flood/import-checklist", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { jsonData, typ } = req.body;
      
      if (!jsonData || !typ) {
        return res.status(400).json({ message: "JSON-Daten und Typ sind erforderlich" });
      }

      // Create checklist with dummy data for now
      const checklistId = Date.now().toString();
      
      res.status(201).json({ 
        success: true, 
        checklistId,
        message: `Checkliste "${jsonData.title}" erfolgreich importiert` 
      });
    } catch (error) {
      console.error("Fehler beim Import der Checkliste:", error);
      res.status(500).json({ message: "Fehler beim Import der Checkliste" });
    }
  });

  app.get("/api/flood/checklists", isAuthenticated, async (req: any, res) => {
    try {
      // Echte Datenbank-Abfrage f√ºr Hochwasserschutz-Checklisten
      const checklists = await storage.getFloodChecklists(req.user.id);
      
      // Fallback Demo-Daten wenn keine Checklisten vorhanden
      const fallbackChecklists = checklists.length > 0 ? checklists : [
        {
          id: "1",
          titel: "Hochwasserereignis Mai 2025 (Beispielprojekt)",
          typ: "hochwasser",
          status: "in_bearbeitung",
          erstellt_am: "2025-05-15T08:00:00Z",
          erstellt_von: "Thomas M√ºller",
          beginn_pegelstand_cm: 245,
          fortschritt: 68,
          aufgaben_gesamt: 11,
          aufgaben_erledigt: 7
        },
        {
          id: "2", 
          titel: "Routine√ºbung Fr√ºhjahr (Beispielprojekt)",
          typ: "uebung",
          status: "abgeschlossen",
          erstellt_am: "2025-03-20T10:30:00Z",
          erstellt_von: "Sarah Weber",
          fortschritt: 100,
          aufgaben_gesamt: 11,
          aufgaben_erledigt: 11
        }
      ];
      res.json({
        checklists: checklists.length > 0 ? checklists : fallbackChecklists,
        isDemo: checklists.length === 0,
        message: checklists.length === 0 ? "Keine Checklisten vorhanden. Erstellen Sie Ihre erste Checkliste." : undefined
      });
    } catch (error) {
      console.error("Fehler beim Laden der Checklisten:", error);
      res.status(500).json({ message: "Fehler beim Laden der Checklisten" });
    }
  });

  app.post("/api/flood/create-checklist", isAuthenticated, async (req: any, res) => {
    try {
      console.log("=== CREATE CHECKLIST REQUEST ===");
      console.log("User:", req.user?.id);
      console.log("Authenticated:", req.isAuthenticated());
      console.log("Body:", JSON.stringify(req.body, null, 2));
      
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const { titel, typ, beginn_pegelstand_cm, beschreibung } = req.body;

      // LIZENZ-LIMITIERUNG: Hochwasserschutz nur f√ºr Professional und Enterprise
      const licenseFeatures = getLicenseFeatures(user?.licenseType || 'basic');
      if (!licenseFeatures.allowsHochwasserschutz) {
        console.log(`üö´ HOCHWASSERSCHUTZ BLOCKED: UserID: ${userId}, License: ${user?.licenseType || 'basic'}`);
        return res.status(403).json({
          error: 'Feature not available',
          message: 'Das Hochwasserschutz-Modul erfordert eine Professional oder Enterprise Lizenz.',
          feature: 'Hochwasserschutz',
          requiredLicense: 'professional',
          currentLicense: user?.licenseType || 'basic',
          upgradeUrl: '/checkout?plan=professional'
        });
      }
      
      if (!titel || !typ) {
        console.log("Validation failed - missing titel or typ");
        return res.status(400).json({ message: "Titel und Typ sind erforderlich" });
      }

      // Erstelle neue Checkliste mit Demo-ID
      const newChecklist = {
        id: Date.now().toString(),
        titel,
        typ,
        status: "offen",
        erstellt_am: new Date().toISOString(),
        erstellt_von: userId,
        beginn_pegelstand_cm: beginn_pegelstand_cm || 0,
        beschreibung: beschreibung || "",
        fortschritt: 0,
        aufgaben_gesamt: 11,
        aufgaben_erledigt: 0
      };
      
      console.log("=== CHECKLIST CREATED SUCCESSFULLY ===");
      console.log("New checklist:", JSON.stringify(newChecklist, null, 2));
      
      res.status(201).json({ 
        success: true, 
        checklist: newChecklist,
        message: `Checkliste "${titel}" erfolgreich erstellt` 
      });
    } catch (error) {
      console.error("=== CHECKLIST CREATION ERROR ===");
      console.error("Error:", error);
      console.error("Error stack:", error instanceof Error ? error.stack : 'No stack');
      res.status(500).json({ message: "Fehler beim Erstellen der Checkliste" });
    }
  });

  app.delete("/api/flood/checklists/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // In a real app, we would delete from database
      // await db.delete(checklisten).where(eq(checklisten.id, id));
      
      res.json({ 
        success: true, 
        message: `Checkliste ${id} wurde gel√∂scht` 
      });
    } catch (error) {
      console.error("Fehler beim L√∂schen der Checkliste:", error);
      res.status(500).json({ message: "Fehler beim L√∂schen der Checkliste" });
    }
  });

  app.delete("/api/flood/checklists/delete-all", isAuthenticated, async (req: any, res) => {
    try {
      // In a real app, we would delete all checklists from database
      // await db.delete(checklisten);
      
      res.json({ 
        success: true, 
        message: "Alle Checklisten wurden gel√∂scht" 
      });
    } catch (error) {
      console.error("Fehler beim L√∂schen aller Checklisten:", error);
      res.status(500).json({ message: "Fehler beim L√∂schen aller Checklisten" });
    }
  });

  app.post("/api/flood/checklists/duplicate", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { checklistId } = req.body;
      
      // In a real app, we would duplicate the checklist in database
      const duplicatedChecklist = {
        id: Date.now().toString(),
        titel: `Kopie - Checkliste ${checklistId}`,
        typ: "hochwasser",
        status: "offen",
        erstellt_am: new Date().toISOString(),
        erstellt_von: userId,
        beginn_pegelstand_cm: 0,
        beschreibung: "Duplizierte Checkliste",
        fortschritt: 0,
        aufgaben_gesamt: 11,
        aufgaben_erledigt: 0
      };
      
      res.status(201).json({ 
        success: true, 
        checklist: duplicatedChecklist,
        message: "Checkliste wurde dupliziert" 
      });
    } catch (error) {
      console.error("Fehler beim Duplizieren der Checkliste:", error);
      res.status(500).json({ message: "Fehler beim Duplizieren der Checkliste" });
    }
  });

  app.get("/api/flood/absperrschieber", isAuthenticated, async (req: any, res) => {
    try {
      // Echte Datenbank-Abfrage f√ºr Absperrschieber
      const schieber = await storage.getFloodGates(req.user.id);
      
      // Fallback Demo-Daten wenn keine Schieber vorhanden
      const fallbackSchieber = schieber.length > 0 ? schieber : [
        {
          id: 1,
          nummer: 1,
          bezeichnung: "Absperrschieber DN 300",
          lage: "Lohr km 1,470, N√§he Kupferm√ºhle",
          beschreibung: "Absperrschieber DN 300 mit Festspindel bis unter die Schachtdeckelunterkante",
          funktionsfaehig: true,
          letzte_pruefung: "2025-06-25T00:00:00Z",
          aktiv: true
        },
        {
          id: 2,
          nummer: 2,
          bezeichnung: "Absperrsch√ºtz bei ehem. Grundwehr", 
          lage: "Lohr km 1,320",
          beschreibung: "Absperrsch√ºtz bei ehem. Grundwehr",
          funktionsfaehig: false,
          letzte_pruefung: "2025-06-20T00:00:00Z",
          aktiv: true
        }
      ];
      res.json({
        schieber: schieber.length > 0 ? schieber : fallbackSchieber,
        isDemo: schieber.length === 0,
        message: schieber.length === 0 ? "Keine Absperrschieber vorhanden. F√ºgen Sie den ersten hinzu." : undefined
      });
    } catch (error) {
      console.error("Fehler beim Laden der Absperrschieber:", error);
      res.status(500).json({ message: "Fehler beim Laden der Absperrschieber" });
    }
  });

  // Flood Protection PDF Export
  app.post("/api/flood-protection/export-pdf", isAuthenticated, async (req: any, res) => {
    try {
      const { checklist, schieber, schaeden, wachen, exportedAt, exportedBy } = req.body;
      
      console.log('PDF-Export gestartet f√ºr Checkliste:', checklist.titel);
      
      // Generiere PDF mit dem echten PDF-Generator
      const { generateFloodProtectionPDF } = await import('./pdfGenerator');
      
      const pdfBuffer = await generateFloodProtectionPDF({
        checklist,
        schieber,
        schaeden,
        wachen,
        exportedAt,
        exportedBy
      });

      // Setze korrekte PDF-Headers
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="Hochwasserschutz-Checkliste-${checklist.titel.replace(/[^a-zA-Z0-9]/g, '-')}-${new Date().toISOString().split('T')[0]}.pdf"`);
      res.setHeader('Content-Length', pdfBuffer.length);
      
      console.log('PDF erfolgreich generiert, Gr√∂√üe:', pdfBuffer.length, 'bytes');
      res.send(pdfBuffer);
      
    } catch (error) {
      console.error("Fehler beim PDF-Export:", error);
      res.status(500).json({ message: "Fehler beim PDF-Export: " + (error as Error).message });
    }
  });

  // BREVO E-Mail Test-Route
  app.post("/api/test-brevo", isAuthenticated, async (req: any, res) => {
    try {
      const { emailService } = await import('./emailService');
      
      await emailService.sendWelcomeEmail({
        to: 'lea.zimmer@gmx.net', // Test an echte E-Mail-Adresse
        firstName: 'Lea',
        role: 'admin'
      });

      res.json({ success: true, message: 'Test-E-Mail wurde erfolgreich √ºber BREVO gesendet!' });
    } catch (error: any) {
      console.error('BREVO Test-Fehler:', error);
      res.status(500).json({ 
        success: false, 
        message: 'BREVO Test fehlgeschlagen',
        error: error.message
      });
    }
  });

  // üìß E-MAIL-WEITERLEITUNG: BREVO Inbound Webhook
  app.post('/api/inbound-email', async (req, res) => {
    await emailForwardingService.handleInboundEmail(req, res);
  });

  // üîß E-Mail-Weiterleitungsregeln verwalten (Admin)
  app.get('/api/email-forwarding/rules', requireAdmin, (req: any, res) => {
    try {
      const rules = emailForwardingService.getForwardingRules();
      res.json({ success: true, rules });
    } catch (error: any) {
      res.status(500).json({ success: false, error: error.message });
    }
  });

  app.post('/api/email-forwarding/rules', requireAdmin, (req: any, res) => {
    try {
      const { from, to, active } = req.body;
      const success = emailForwardingService.updateForwardingRule(from, to, active);
      res.json({ success, message: 'Weiterleitungsregel aktualisiert' });
    } catch (error: any) {
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // üìã Setup-Anweisungen f√ºr BREVO Inbound API abrufen
  app.get('/api/email-forwarding/setup', requireAdmin, (req: any, res) => {
    try {
      const instructions = emailForwardingService.getSetupInstructions();
      res.json({ success: true, instructions });
    } catch (error: any) {
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // Flood Protection E-Mail Versand
  app.post("/api/flood-protection/send-email", isAuthenticated, async (req: any, res) => {
    try {
      const { to, subject, message, checklist, schieber, schaeden, wachen, includePdf } = req.body;
      
      if (!to || !subject) {
        return res.status(400).json({ message: "E-Mail-Adresse und Betreff sind erforderlich" });
      }

      // E-Mail-Inhalt zusammenstellen
      const emailText = `
${message}

--- Checklisten-Details ---
Titel: ${checklist.titel}
Typ: ${checklist.typ}
Status: ${checklist.status}
Erstellt von: ${checklist.erstellt_von}
Fortschritt: ${checklist.aufgaben_erledigt || 0}/${checklist.aufgaben_gesamt || 11} Aufgaben
${checklist.beginn_pegelstand_cm ? `Pegelstand: ${checklist.beginn_pegelstand_cm} cm` : ''}

Absperrschieber-Status:
${schieber.map((s: any) => `- Nr. ${s.nummer}: ${s.bezeichnung} (${s.status})`).join('\n')}

${schaeden && schaeden.length > 0 ? `
Schadensf√§lle:
${schaeden.map((schaden: any) => `- Schieber ${schaden.absperrschieber_nummer}: ${schaden.problem_beschreibung} (${schaden.status})`).join('\n')}
` : ''}

---
Diese E-Mail wurde automatisch generiert vom Bau-Structura Hochwasserschutz-System.
      `;

      // E-Mail √ºber BREVO senden
      const { emailService } = await import('./emailService');
      
      await emailService.sendFloodProtectionEmail({
        to,
        subject,
        message,
        checklist,
        schieber,
        schaeden,
        wachen,
        includePdf
      });

      console.log('Hochwasserschutz-E-Mail erfolgreich √ºber BREVO gesendet an:', to);

      res.json({ 
        success: true, 
        message: `E-Mail erfolgreich an ${to} gesendet` 
      });
      
    } catch (error) {
      console.error("Fehler beim E-Mail-Versand:", error);
      res.status(500).json({ message: "Fehler beim E-Mail-Versand" });
    }
  });

  // Support Ticket routes
  app.get("/api/support-tickets", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      const tickets = await storage.getSupportTickets();
      
      // Filter tickets based on role
      let filteredTickets = tickets;
      if (user?.role === "user") {
        // Users can only see their own tickets
        filteredTickets = tickets.filter(ticket => ticket.createdBy === userId);
      }
      // Admins and managers can see all tickets
      
      res.json(filteredTickets);
    } catch (error) {
      console.error("Error fetching support tickets:", error);
      res.status(500).json({ message: "Failed to fetch support tickets" });
    }
  });

  app.post("/api/support-tickets", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { subject, description, priority = "medium" } = req.body;
      
      if (!subject || !description) {
        return res.status(400).json({ message: "Subject and description are required" });
      }
      
      const ticketData = {
        subject,
        description,
        priority,
        status: "open",
        createdBy: userId,
        emailHistory: []
      };
      
      const ticket = await storage.createSupportTicket(ticketData);
      
      // Send email notification
      const { emailService } = await import('./emailService');
      try {
        await emailService.sendSupportTicketEmail({
          to: user.email || '',
          subject: ticket.subject,
          description: ticket.description || '',
          ticketId: ticket.id,
          priority: ticket.priority || 'medium'
        });
      } catch (emailError) {
        console.error("Failed to send email, but ticket was created:", emailError);
      }
      
      res.status(201).json(ticket);
    } catch (error) {
      console.error("Error creating support ticket:", error);
      res.status(500).json({ message: "Failed to create support ticket" });
    }
  });

  app.patch("/api/support-tickets/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const ticketId = parseInt(req.params.id);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the ticket to check permissions
      const tickets = await storage.getSupportTickets();
      const ticket = tickets.find(t => t.id === ticketId);
      
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      // Users can only update their own tickets, admins/managers can update all
      if (user.role === "user" && ticket.createdBy !== userId) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      const { status, assignedTo, updateMessage, subject, description, priority } = req.body;
      
      const updateData: any = {};
      if (status) updateData.status = status;
      if (assignedTo) updateData.assignedTo = assignedTo;
      if (subject) updateData.subject = subject;
      if (description) updateData.description = description;
      if (priority) updateData.priority = priority;
      
      const updatedTicket = await storage.updateSupportTicket(ticketId, updateData);
      
      // Send update email for any change (but only if the editor is different from ticket owner)
      if (ticket.createdBy !== userId) {
        const { emailService } = await import('./emailService');
        try {
          const ticketOwner = await storage.getUser(ticket.createdBy || '');
          if (ticketOwner?.email) {
            // Generate automatic update message based on changes
            let autoUpdateMessage = updateMessage || 'Ihr Support-Ticket wurde bearbeitet.';
            
            const changes = [];
            if (subject && subject !== ticket.subject) changes.push(`Betreff ge√§ndert zu: "${subject}"`);
            if (description && description !== ticket.description) changes.push('Beschreibung wurde aktualisiert');
            if (priority && priority !== ticket.priority) changes.push(`Priorit√§t ge√§ndert zu: ${getPriorityLabel(priority)}`);
            if (status && status !== ticket.status) changes.push(`Status ge√§ndert zu: ${getStatusLabel(status)}`);
            
            if (changes.length > 0) {
              autoUpdateMessage = `Folgende √Ñnderungen wurden vorgenommen:\n\n${changes.join('\n')}\n\n${updateMessage || ''}`;
            }

            await emailService.sendTicketUpdateEmail({
              to: ticketOwner.email,
              ticketId: updatedTicket.id,
              subject: updatedTicket.subject,
              status: updatedTicket.status || 'open',
              updateMessage: autoUpdateMessage,
              assignedTo: updatedTicket.assignedTo || undefined,
              editorName: `${user.firstName || user.id} ${user.lastName || ''}`.trim()
            });
          }
        } catch (emailError) {
          console.error("Failed to send update email:", emailError);
        }
      }
      
      res.json(updatedTicket);
    } catch (error) {
      console.error("Error updating support ticket:", error);
      res.status(500).json({ message: "Failed to update support ticket" });
    }
  });

  // Admin routes (only for admin role)
  const isAdmin = async (req: any, res: any, next: any) => {
    if (!req.user?.id) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    try {
      const user = await storage.getUserById(req.user.id);
      if (!user || user.role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }
      next();
    } catch (error) {
      console.error("Error checking admin role:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  };

  // Get all users (admin only)
  app.get("/api/admin/users", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // Helper functions for labels
  function getPriorityLabel(priority: string): string {
    switch (priority) {
      case 'low': return 'Niedrig';
      case 'medium': return 'Mittel';
      case 'high': return 'Hoch';
      case 'urgent': return 'Dringend';
      default: return priority;
    }
  }

  function getStatusLabel(status: string): string {
    switch (status) {
      case 'open': return 'Offen';
      case 'in_progress': return 'In Bearbeitung';
      case 'resolved': return 'Gel√∂st';
      case 'closed': return 'Geschlossen';
      default: return status;
    }
  }

  // Generate secure password
  function generateSecurePassword(): string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*";
    let password = "";
    for (let i = 0; i < 12; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    return password;
  }

  // Create new user (admin only)
  app.post("/api/admin/users", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { username, email, role, licenseType } = req.body;
      
      if (!username || !email) {
        return res.status(400).json({ message: "Username and email are required" });
      }
      
      // Check if user already exists
      const existingUser = await storage.getUser(username);
      if (existingUser) {
        return res.status(409).json({ message: "Username bereits vergeben" });
      }
      
      // Generate secure password
      const temporaryPassword = generateSecurePassword();
      
      const userData = {
        id: username,
        username,
        email,
        role: role || 'user',
        licenseType: licenseType || 'basic',
        firstName: username, // Use username as firstName for now
        lastName: '',
        emailNotificationsEnabled: true,
        password: temporaryPassword, // Store password temporarily (in real app, hash it)
        createdAt: new Date(),
        updatedAt: new Date()
      };
      
      const newUser = await storage.upsertUser(userData);
      
      // Send welcome email with password
      const { emailService } = await import('./emailService');
      try {
        await emailService.sendWelcomeEmail({
          to: email,
          firstName: username,
          role: role || 'user',
          password: temporaryPassword
        });
      } catch (emailError) {
        console.error("Failed to send welcome email:", emailError);
      }
      
      // Remove password from response for security
      const { password, ...userWithoutPassword } = newUser;
      
      res.status(201).json({
        ...userWithoutPassword,
        passwordSent: true,
        message: "Benutzer erstellt und Passwort per E-Mail versendet"
      });
    } catch (error) {
      console.error("Error creating user:", error);
      res.status(500).json({ message: "Failed to create user" });
    }
  });

  // Change user role (admin only)
  app.put("/api/admin/users/:id/role", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { role } = req.body;
      
      // Validate role
      if (!['user', 'manager', 'admin'].includes(role)) {
        return res.status(400).json({ message: "Ung√ºltige Rolle" });
      }
      
      console.log(`Admin ${req.user.email} changing role for user ${id} to ${role}`);
      
      // Find user by ID or email
      let user = await storage.getUser(id);
      if (!user) {
        user = await storage.getUserByEmail(id);
      }
      
      if (!user) {
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      
      // Prevent admin from changing their own role
      if (user.id === req.user.id) {
        return res.status(400).json({ message: "Sie k√∂nnen Ihre eigene Rolle nicht √§ndern" });
      }
      
      // Update user role in database
      await storage.updateUser(user.id, { role });
      
      console.log(`‚úÖ Role updated: ${user.email} -> ${role}`);
      
      // Update session if the user is currently logged in
      // This prevents the need for re-login after role change
      const sessionStore = req.sessionStore;
      if (sessionStore) {
        sessionStore.all((err: any, sessions: any) => {
          if (err) {
            console.warn('Could not access session store for role update:', err);
            return;
          }
          
          // Find sessions belonging to the user whose role was changed
          Object.keys(sessions || {}).forEach(sessionId => {
            const session = sessions[sessionId];
            if (session?.passport?.user === user.id) {
              console.log(`üîÑ Updating session for user ${user.email} with new role: ${role}`);
              
              // Update the session data (if user object is stored in session)
              sessionStore.get(sessionId, (getErr: any, sessionData: any) => {
                if (!getErr && sessionData) {
                  // Update role in session if user data exists
                  if (sessionData.user) {
                    sessionData.user.role = role;
                  }
                  
                  // Save updated session
                  sessionStore.set(sessionId, sessionData, (setErr: any) => {
                    if (setErr) {
                      console.warn('Failed to update session:', setErr);
                    } else {
                      console.log(`‚úÖ Session updated for user ${user.email}`);
                    }
                  });
                }
              });
            }
          });
        });
      }
      
      res.json({ 
        success: true, 
        message: `Rolle von ${user.email} zu ${role} ge√§ndert. Die √Ñnderung ist sofort aktiv.`,
        user: { 
          id: user.id, 
          email: user.email, 
          role: role,
          firstName: user.firstName,
          lastName: user.lastName
        }
      });
    } catch (error) {
      console.error("Error changing user role:", error);
      res.status(500).json({ message: "Rolle konnte nicht ge√§ndert werden" });
    }
  });

  // Reset user password (admin only)
  app.post("/api/admin/users/:id/reset-password", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      console.log("Password reset request for:", id);
      
      // Try to find user by ID first, then by email
      let user = await storage.getUser(id);
      if (!user) {
        console.log("User not found by ID, trying email:", id);
        // If not found by ID, try to find by email
        user = await storage.getUserByEmail(id);
      }
      
      if (!user) {
        console.log("User not found:", id);
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      
      console.log("Found user:", user.email, "ID:", user.id);
      
      // Generate new password
      const newPassword = generateSecurePassword();
      console.log("Generated new password for user:", user.email);
      
      // Hash the new password before storing
      const { hashPassword } = await import('./localAuth');
      const hashedPassword = await hashPassword(newPassword);
      
      // Update user with new hashed password (use actual user ID)
      await storage.updateUser(user.id, { password: hashedPassword });
      console.log("Password updated in database for user:", user.email);
      
      // Send password reset email
      const { emailService } = await import('./emailService');
      try {
        await emailService.sendWelcomeEmail({
          to: user.email || '',
          firstName: user.firstName || user.id,
          role: user.role || 'user',
          password: newPassword
        });
        console.log("Password reset email sent to:", user.email);
      } catch (emailError) {
        console.error("Failed to send password reset email:", emailError);
        return res.status(500).json({ message: "E-Mail-Versand fehlgeschlagen" });
      }
      
      res.json({ 
        success: true, 
        message: `Neues Passwort an ${user.email} gesendet` 
      });
    } catch (error) {
      console.error("Error resetting password:", error);
      res.status(500).json({ message: "Passwort konnte nicht zur√ºckgesetzt werden" });
    }
  });

  // Update user (admin only)
  app.patch("/api/admin/users/:id", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;
      
      // Validate update data
      const allowedFields = ['firstName', 'lastName', 'email', 'role', 'emailNotificationsEnabled'];
      const filteredData = Object.keys(updateData)
        .filter(key => allowedFields.includes(key))
        .reduce((obj: any, key) => {
          obj[key] = updateData[key];
          return obj;
        }, {});

      const user = await storage.updateUser(id, filteredData);
      res.json(user);
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({ message: "Failed to update user" });
    }
  });

  // Delete user (admin only)
  app.delete("/api/admin/users/:id", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { id } = req.params;
      
      // Prevent admin from deleting themselves
      if (id === req.user.id) {
        return res.status(400).json({ message: "Cannot delete your own account" });
      }

      await storage.deleteUser(id);
      res.json({ message: "User deleted successfully" });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Failed to delete user" });
    }
  });

  // Get error learning statistics for admin dashboard
  app.get("/api/admin/error-learning/stats", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { errorLearningSystem } = await import('../shared/error-learning-system');
      const stats = errorLearningSystem.getErrorStatistics();
      const patterns = errorLearningSystem.getAllPatterns();
      
      res.json({
        stats,
        patterns
      });
    } catch (error) {
      console.error("Error fetching error learning statistics:", error);
      res.status(500).json({ message: "Fehler beim Laden der Statistiken" });
    }
  });

  // Get system statistics (admin only)
  app.get("/api/admin/stats", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const stats = await storage.getSystemStats();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching system stats:", error);
      res.status(500).json({ message: "Failed to fetch system stats" });
    }
  });

  // Create database backup (admin only)
  app.post("/api/admin/backup", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const backupData = await storage.createBackup();
      
      res.setHeader('Content-Type', 'application/sql');
      res.setHeader('Content-Disposition', `attachment; filename="backup-${new Date().toISOString().split('T')[0]}.sql"`);
      res.send(backupData);
    } catch (error) {
      console.error("Error creating backup:", error);
      res.status(500).json({ message: "Failed to create backup" });
    }
  });

  // OpenAI AI Integration routes (EU AI Act konform)
  app.post('/api/ai/generate-description', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const { name, location, budget, category } = req.body;

      // LIZENZ-LIMITIERUNG: KI-Features nur f√ºr Enterprise
      const licenseFeatures = getLicenseFeatures(user?.licenseType || 'basic');
      if (!licenseFeatures.allowsAI) {
        console.log(`üö´ KI-BESCHREIBUNG BLOCKED: UserID: ${userId}, License: ${user?.licenseType || 'basic'}`);
        return res.status(403).json({
          error: 'Premium Feature',
          message: 'KI-Projektbeschreibung erfordert eine Enterprise-Lizenz.',
          feature: 'KI-Projektbeschreibung',
          requiredLicense: 'enterprise',
          currentLicense: user?.licenseType || 'basic',
          upgradeUrl: '/checkout?plan=enterprise',
          aiGenerated: false
        });
      }

      const { generateProjectDescription } = await import('./openai');
      const result = await generateProjectDescription(userId, {
        name,
        location,
        budget: budget ? parseFloat(budget) : undefined,
        category,
      });

      res.json(result);
    } catch (error) {
      console.error("AI description generation error:", error);
      res.status(500).json({ 
        error: "KI-Beschreibung konnte nicht generiert werden",
        aiGenerated: false 
      });
    }
  });

  app.post('/api/ai/risk-assessment', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const { name, location, budget, description, duration, projectId } = req.body;

      // LIZENZ-LIMITIERUNG: KI-Features nur f√ºr Enterprise
      const licenseFeatures = getLicenseFeatures(user?.licenseType || 'basic');
      if (!licenseFeatures.allowsAI) {
        console.log(`üö´ KI-RISIKOBEWERTUNG BLOCKED: UserID: ${userId}, License: ${user?.licenseType || 'basic'}`);
        return res.status(403).json({
          error: 'Premium Feature',
          message: 'KI-Risikobewertung erfordert eine Enterprise-Lizenz.',
          feature: 'KI-Risikobewertung',
          requiredLicense: 'enterprise',
          currentLicense: user?.licenseType || 'basic',
          upgradeUrl: '/checkout?plan=enterprise',
          aiGenerated: false
        });
      }

      const { generateRiskAssessment } = await import('./openai');
      const result = await generateRiskAssessment(userId, {
        name,
        location,
        budget: budget ? parseFloat(budget) : undefined,
        description,
        duration: duration ? parseInt(duration) : undefined,
      }, projectId);

      res.json(result);
    } catch (error) {
      console.error("AI risk assessment error:", error);
      res.status(500).json({ 
        error: "Risikobewertung konnte nicht erstellt werden",
        aiGenerated: false 
      });
    }
  });

  app.post('/api/ai/project-chat', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      const { question, projectContext, projectId } = req.body;

      // LIZENZ-LIMITIERUNG: KI-Features nur f√ºr Enterprise
      const licenseFeatures = getLicenseFeatures(user?.licenseType || 'basic');
      if (!licenseFeatures.allowsAI) {
        console.log(`üö´ KI-CHAT BLOCKED: UserID: ${userId}, License: ${user?.licenseType || 'basic'}`);
        return res.status(403).json({
          error: 'Premium Feature',
          message: 'KI-Assistent erfordert eine Enterprise-Lizenz.',
          feature: 'KI-Assistent',
          requiredLicense: 'enterprise',
          currentLicense: user?.licenseType || 'basic',
          upgradeUrl: '/checkout?plan=enterprise',
          aiGenerated: false
        });
      }

      const { aiProjectChat } = await import('./openai');
      const result = await aiProjectChat(userId, question, projectContext, projectId);

      res.json(result);
    } catch (error) {
      console.error("AI project chat error:", error);
      res.status(500).json({ 
        error: "KI-Beratung ist momentan nicht verf√ºgbar",
        aiGenerated: false 
      });
    }
  });

  app.get('/api/ai/usage-stats', isAuthenticated, async (req: any, res) => {
    try {
      const { getAIUsageStats } = await import('./openai');
      const userId = req.user.id;

      const stats = await getAIUsageStats(userId);
      res.json(stats);
    } catch (error) {
      console.error("AI usage stats error:", error);
      res.status(500).json({ 
        error: "Statistiken konnten nicht geladen werden" 
      });
    }
  });

  // Photos routes
  app.get('/api/photos', isAuthenticated, async (req: any, res) => {
    try {
      const projectId = req.query.projectId;
      if (projectId) {
        const photos = await storage.getPhotos(parseInt(projectId));
        res.json(photos);
      } else {
        // Alle Fotos f√ºr den Benutzer
        const projects = await storage.getProjects();
        const allPhotos = [];
        for (const project of projects) {
          const photos = await storage.getPhotos(project.id);
          allPhotos.push(...photos);
        }
        res.json(allPhotos);
      }
    } catch (error) {
      console.error("Error fetching photos:", error);
      res.status(500).json({ message: "Failed to fetch photos" });
    }
  });

  app.post('/api/photos', isAuthenticated, async (req: any, res) => {
    try {
      const { projectId, description, imageData, latitude, longitude } = req.body;
      const userId = req.user.id;

      if (!projectId || !imageData) {
        return res.status(400).json({ message: "Project ID and image data are required" });
      }

      // Base64-Bild in Buffer konvertieren (f√ºr echte Implementierung)
      // Hier w√ºrde normalerweise das Bild auf einem File-Server gespeichert
      const imageBuffer = Buffer.from(imageData.split(',')[1], 'base64');
      const fileName = `photo_${Date.now()}.jpg`;
      
      // Mock: Foto-URL (in echter Implementierung w√ºrde hier Cloud Storage verwendet)
      const photoUrl = `/uploads/photos/${fileName}`;

      const photo = await storage.createPhoto({
        projectId: parseInt(projectId),
        fileName,
        filePath: photoUrl,
        description: description || '',
        gpsLatitude: latitude ? latitude.toString() : null,
        gpsLongitude: longitude ? longitude.toString() : null,
        takenBy: userId,
      });

      res.json({ ...photo, message: "Photo saved successfully" });
    } catch (error) {
      console.error("Error saving photo:", error);
      res.status(500).json({ 
        message: "Failed to save photo", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Audio Records routes
  app.get('/api/audio-records', isAuthenticated, async (req: any, res) => {
    try {
      const projectId = req.query.projectId;
      if (projectId) {
        const records = await storage.getAudioRecords(parseInt(projectId));
        res.json(records);
      } else {
        // Alle Audio-Aufnahmen f√ºr den Benutzer
        const projects = await storage.getProjects();
        const allRecords = [];
        for (const project of projects) {
          const records = await storage.getAudioRecords(project.id);
          allRecords.push(...records);
        }
        res.json(allRecords);
      }
    } catch (error) {
      console.error("Error fetching audio records:", error);
      res.status(500).json({ message: "Failed to fetch audio records" });
    }
  });

  app.post('/api/audio-records', isAuthenticated, async (req: any, res) => {
    try {
      const { projectId, description, audioData, duration, transcription, latitude, longitude } = req.body;
      const userId = req.user.id;

      if (!projectId || !audioData) {
        return res.status(400).json({ message: "Project ID and audio data are required" });
      }

      // Base64-Audio in Buffer konvertieren (f√ºr echte Implementierung)
      // Hier w√ºrde normalerweise das Audio auf einem File-Server gespeichert
      const audioBuffer = Buffer.from(audioData.split(',')[1], 'base64');
      const fileName = `audio_${Date.now()}.webm`;
      
      // Mock: Audio-URL (in echter Implementierung w√ºrde hier Cloud Storage verwendet)
      const audioUrl = `/uploads/audio/${fileName}`;

      const record = await storage.createAudioRecord({
        projectId: parseInt(projectId),
        fileName,
        filePath: audioUrl,
        duration: duration || 0,
        description: description || '',
        transcription: transcription || null,
        gpsLatitude: latitude ? latitude.toString() : null,
        gpsLongitude: longitude ? longitude.toString() : null,
        recordedBy: userId,
      });

      res.json({ ...record, message: "Audio record saved successfully" });
    } catch (error) {
      console.error("Error saving audio record:", error);
      res.status(500).json({ 
        message: "Failed to save audio record", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Audio Transcription route (Mock - w√ºrde normalerweise OpenAI Whisper verwenden)
  app.post('/api/audio/transcribe', isAuthenticated, async (req: any, res) => {
    try {
      const { audioData } = req.body;

      if (!audioData) {
        return res.status(400).json({ message: "Audio data is required" });
      }

      // ‚ö†Ô∏è SIMULATION: In Produktionsumgebung wird OpenAI Whisper API verwendet
      const simulationTranscriptions = [
        "[SIMULATION] Die Bauarbeiten am Fundament sind heute planm√§√üig vorangeschritten. Die Betonierung wurde erfolgreich abgeschlossen.",
        "[SIMULATION] Heute wurde die Bewehrung f√ºr die Bodenplatte eingebaut. Qualit√§tspr√ºfung durch den Statiker erfolgt morgen.",
        "[SIMULATION] Fortschritt bei der Rohrleitungsverlegung. Alle Anschl√ºsse sind fachgerecht ausgef√ºhrt worden.",
        "[SIMULATION] Die Erdarbeiten sind abgeschlossen. N√§chster Schritt ist die Verdichtung des Untergrunds.",
        "[SIMULATION] Schalung f√ºr die St√ºtzen wurde heute aufgestellt. Betonage ist f√ºr morgen geplant."
      ];

      const randomTranscription = simulationTranscriptions[Math.floor(Math.random() * simulationTranscriptions.length)];

      // Simulation einer kleinen Verz√∂gerung wie bei echter API
      await new Promise(resolve => setTimeout(resolve, 2000));

      res.json({ 
        transcription: randomTranscription,
        confidence: 0.95,
        language: "de",
        isSimulation: true,
        message: "‚ö†Ô∏è Dies ist eine simulierte Transkription. F√ºr echte Spracherkennung wird OpenAI Whisper API ben√∂tigt."
      });
    } catch (error) {
      console.error("Error transcribing audio:", error);
      res.status(500).json({ 
        message: "Failed to transcribe audio", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // E-Mail Test Endpunkt (Admin only) - Mit Mock f√ºr Demo
  app.post("/api/email/test", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (!user?.email) {
        return res.status(400).json({ message: "User email not found" });
      }

      // F√ºr Demo: Mock-E-Mail-Versand (produktive BREVO-Integration vorbereitet)
      console.log('Mock E-Mail Test f√ºr:', user.email);
      
      // Simulation der E-Mail-Verarbeitung
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      res.json({ 
        success: true, 
        message: `Demo: Test-E-Mail w√ºrde an ${user.email} gesendet (BREVO-Integration vorbereitet)`,
        timestamp: new Date().toISOString(),
        emailContent: {
          subject: "Willkommen bei Bau-Structura!",
          to: user.email,
          from: process.env.SENDER_EMAIL || 'support@bau-structura.de',
          type: "Willkommens-E-Mail"
        },
        brevoStatus: "Konfiguriert - Bereit f√ºr Produktion"
      });
    } catch (error) {
      console.error("E-Mail Test Fehler:", error);
      res.status(500).json({ 
        success: false,
        message: "E-Mail Test fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Test der erweiterten Willkommens-E-Mail (Admin only)
  app.post("/api/email/test-welcome", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { emailService } = await import('./emailService');
      const testEmail = req.body.testEmail || 'firielster@googlemail.com';
      
      console.log(`üß™ Sende Test-Willkommens-E-Mail an: ${testEmail}`);
      
      // Teste die erweiterte Willkommens-E-Mail mit User-Rolle
      await emailService.sendWelcomeEmail({
        to: testEmail,
        firstName: 'Test',
        role: 'user',
        id: 'test_id_123'
      });

      res.json({ 
        success: true, 
        message: `Erweiterte Willkommens-E-Mail erfolgreich an ${testEmail} gesendet`,
        timestamp: new Date().toISOString(),
        features: [
          '‚úÖ Berechtigungen f√ºr User-Rolle erkl√§rt',
          'üö´ Einschr√§nkungen klar aufgezeigt',
          'üí° Upgrade-Hinweise integriert',
          'üìÇ SFTP-Account-Informationen',
          'üì± PWA-Installationsanleitung'
        ]
      });
    } catch (error) {
      console.error("Test-Willkommens-E-Mail Fehler:", error);
      res.status(500).json({ 
        success: false,
        message: "Test-Willkommens-E-Mail fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Backup-Verwaltung Endpunkte
  app.post("/api/admin/backup/create", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      console.log('Erstelle Datenbank-Backup...');
      const backupId = await storage.createBackup();
      
      res.json({ 
        success: true, 
        message: "Backup erfolgreich erstellt",
        backupId: backupId,
        timestamp: new Date().toISOString(),
        size: "Vollst√§ndiger Datenexport",
        retention: "30 Tage"
      });
    } catch (error) {
      console.error("Backup-Erstellung Fehler:", error);
      res.status(500).json({ 
        success: false,
        message: "Backup-Erstellung fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.get("/api/admin/backup/status", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const lastBackup = new Date();
      lastBackup.setHours(2, 0, 0, 0); // Simuliere letztes Backup um 02:00
      
      res.json({ 
        automaticBackups: true,
        retention: 30,
        encryptedStorage: true,
        lastBackup: lastBackup.toISOString(),
        nextBackup: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // Morgen
        backupSize: "15.7 MB",
        status: "Aktiv",
        storage: "Azure Blob Storage"
      });
    } catch (error) {
      console.error("Backup-Status Fehler:", error);
      res.status(500).json({ 
        success: false,
        message: "Backup-Status abrufen fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Azure Backup-Management Endpunkte
  app.get("/api/admin/backup/list", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { azureBackupService } = await import('./azureBackupService');
      const backups = await azureBackupService.listBackups();
      
      res.json({ 
        success: true,
        backups: backups,
        total: backups.length
      });
    } catch (error) {
      console.error("Azure Backup-Liste Fehler:", error);
      res.status(500).json({ 
        success: false,
        message: "Backup-Liste abrufen fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.get("/api/admin/backup/download/:backupId", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { backupId } = req.params;
      const { azureBackupService } = await import('./azureBackupService');
      const sqlContent = await azureBackupService.downloadBackup(backupId);
      
      res.setHeader('Content-Type', 'application/sql');
      res.setHeader('Content-Disposition', `attachment; filename="${backupId}.sql"`);
      res.send(sqlContent);
    } catch (error) {
      console.error("Azure Backup-Download Fehler:", error);
      res.status(500).json({ 
        success: false,
        message: "Backup-Download fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.post("/api/admin/backup/cleanup", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { retentionDays = 30 } = req.body;
      const { azureBackupService } = await import('./azureBackupService');
      const result = await azureBackupService.cleanupOldBackups(retentionDays);
      
      res.json({ 
        success: true,
        message: `Backup-Cleanup abgeschlossen: ${result.deleted} gel√∂scht, ${result.errors} Fehler`,
        deleted: result.deleted,
        errors: result.errors
      });
    } catch (error) {
      console.error("Azure Backup-Cleanup Fehler:", error);
      res.status(500).json({ 
        success: false,
        message: "Backup-Cleanup fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.get("/api/admin/azure/test", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { azureBackupService } = await import('./azureBackupService');
      const testResult = await azureBackupService.testConnection();
      
      res.json({ 
        success: testResult.connected,
        connection: testResult,
        message: testResult.connected ? "Azure-Verbindung erfolgreich" : "Azure-Verbindung fehlgeschlagen"
      });
    } catch (error) {
      console.error("Azure-Verbindungstest Fehler:", error);
      res.status(500).json({ 
        success: false,
        message: "Azure-Verbindungstest fehlgeschlagen", 
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // BREVO Verbindungstest (Admin only)
  app.post("/api/email/test-connection", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const nodemailer = require('nodemailer');
      
      const testTransporter = nodemailer.createTransport({
        host: 'smtp-relay.brevo.com',
        port: 587,
        secure: false,
        auth: {
          user: process.env.SMTP_USER,
          pass: process.env.SMTP_PASS,
        }
      });

      // Verbindung testen
      await testTransporter.verify();
      
      res.json({
        success: true,
        message: "BREVO SMTP-Verbindung erfolgreich",
        config: {
          host: 'smtp-relay.brevo.com',
          port: 587,
          user: process.env.SMTP_USER,
          authenticated: true
        }
      });
    } catch (error) {
      console.error("BREVO Verbindungstest Fehler:", error);
      res.status(500).json({
        success: false,
        message: "BREVO SMTP-Verbindung fehlgeschlagen",
        error: error instanceof Error ? error.message : 'Unknown error',
        suggestions: [
          "Pr√ºfen Sie SMTP_USER (muss Ihre BREVO-Login-E-Mail sein)",
          "Pr√ºfen Sie SMTP_PASS (muss ein BREVO SMTP-Schl√ºssel sein)",
          "Stellen Sie sicher, dass der SMTP-Schl√ºssel aktiv ist"
        ]
      });
    }
  });

  // E-Mail Status Endpunkt
  app.get("/api/email/status", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { emailService } = await import('./emailService');
      
      // Pr√ºfe BREVO-Konfiguration
      const hasConfig = !!(process.env.SMTP_USER && process.env.SMTP_PASS && process.env.SENDER_EMAIL);
      
      res.json({
        configured: hasConfig,
        smtpHost: 'smtp-relay.brevo.com',
        smtpPort: 587,
        senderEmail: process.env.SENDER_EMAIL || 'nicht konfiguriert',
        lastCheck: new Date().toISOString()
      });
    } catch (error) {
      console.error("E-Mail Status Fehler:", error);
      res.status(500).json({ 
        configured: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // ‚úÖ DUALES SUBSCRIPTION-SYSTEM: Monthly vs Annual
  app.post("/api/create-payment-intent", isAuthenticated, async (req: any, res) => {
    try {
      const { licenseType, subscriptionType = 'annual' } = req.body; // annual (default) oder monthly
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // BASE LICENSE PRICING (Monatlich)
      const monthlyPrices = {
        basic: 21,
        professional: 39,
        enterprise: 99
      };
      
      const monthlyPrice = monthlyPrices[licenseType as keyof typeof monthlyPrices];
      if (!monthlyPrice) {
        return res.status(400).json({ message: "Invalid license type" });
      }
      
      let finalPrice: number;
      let subscriptionInterval: number;
      let description: string;
      
      if (subscriptionType === 'annual') {
        // üéØ 12-MONATE-ZAHLUNG = 10% RABATT
        const annualPrice = monthlyPrice * 12;
        finalPrice = Math.round(annualPrice * 0.9); // 10% Rabatt
        subscriptionInterval = 12;
        description = `${licenseType} Lizenz (12 Monate) - 10% Rabatt`;
      } else {
        // üìÖ MONATLICHE ZAHLUNG = VOLLER PREIS
        finalPrice = monthlyPrice;
        subscriptionInterval = 1;
        description = `${licenseType} Lizenz (monatlich k√ºndbar)`;
      }
      
      console.log(`üí∞ Pricing: ${licenseType} - ${subscriptionType}`);
      console.log(`   Monthly: ${monthlyPrice}‚Ç¨`);
      console.log(`   Annual: ${monthlyPrice * 12 * 0.9}‚Ç¨ (10% Rabatt)`);
      console.log(`   Final: ${finalPrice}‚Ç¨`);
      
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(finalPrice * 100), // Convert to cents
        currency: "eur",
        description: description,
        metadata: {
          licenseType: licenseType,
          subscriptionType: subscriptionType,
          subscriptionInterval: subscriptionInterval.toString(),
          monthlyPrice: monthlyPrice.toString(),
          finalPrice: finalPrice.toString(),
          discount: subscriptionType === 'annual' ? '10' : '0',
          product: 'Bau-Structura License',
          userId: userId.toString(),
          userEmail: user.email || '',
          userName: `${user.firstName || ''} ${user.lastName || ''}`.trim()
        },
      });
      
      res.json({ 
        clientSecret: paymentIntent.client_secret,
        pricing: {
          licenseType,
          subscriptionType,
          monthlyPrice,
          finalPrice,
          discount: subscriptionType === 'annual' ? 10 : 0,
          savings: subscriptionType === 'annual' ? (monthlyPrice * 12) - finalPrice : 0
        }
      });
    } catch (error: any) {
      console.error("Payment intent creation error:", error);
      res.status(500).json({ 
        message: "Error creating payment intent: " + error.message 
      });
    }
  });

  // Check payment status and update user license
  app.get("/api/payment-status", isAuthenticated, async (req: any, res) => {
    try {
      const { payment_intent } = req.query;
      
      if (!payment_intent) {
        return res.status(400).json({ message: "Payment intent ID required" });
      }
      
      const paymentIntent = await stripe.paymentIntents.retrieve(payment_intent as string);
      
      if (paymentIntent.status === 'succeeded') {
        // Update user license
        const userId = req.user.id;
        const licenseType = paymentIntent.metadata.licenseType || 'basic';
        
        // Calculate license expiry (12 months from now)
        const licenseExpiresAt = new Date();
        licenseExpiresAt.setFullYear(licenseExpiresAt.getFullYear() + 1);
        
        const updateData = {
          licenseType: licenseType as 'basic' | 'professional' | 'enterprise',
          paymentStatus: 'paid',
          lastPaymentDate: new Date(),
          licenseExpiresAt: licenseExpiresAt,
          stripeCustomerId: paymentIntent.customer as string || null
        };
        
        await storage.updateUser(userId, updateData);
        
        // ‚úÖ AUTOMATISCHE SFTP-EINRICHTUNG NACH LIZENZ-AKTIVIERUNG
        console.log(`üéâ Lizenz aktiviert f√ºr User ${userId}: ${licenseType}`);
        
        try {
          const sftpResult = await onLicenseActivated(userId, licenseType);
          console.log(`SFTP-Setup Ergebnis:`, sftpResult.success ? '‚úÖ Erfolgreich' : '‚ùå Fehlgeschlagen');
        } catch (sftpError) {
          console.error('SFTP-Setup Fehler:', sftpError);
          // Lizenz bleibt trotzdem aktiv, SFTP kann sp√§ter manuell eingerichtet werden
        }
        
        res.json({
          id: paymentIntent.id,
          status: paymentIntent.status,
          amount: paymentIntent.amount / 100,
          currency: paymentIntent.currency,
          licenseType: licenseType,
          licenseExpiresAt: licenseExpiresAt
        });
      } else {
        res.json({
          id: paymentIntent.id,
          status: paymentIntent.status
        });
      }
    } catch (error: any) {
      console.error("Payment status check error:", error);
      res.status(500).json({ 
        message: "Error checking payment status: " + error.message 
      });
    }
  });

  // ‚úÖ VOLLST√ÑNDIGER STRIPE WEBHOOK HANDLER MIT AUTOMATISCHER LIZENZ-AKTIVIERUNG UND E-MAIL-BEST√ÑTIGUNG
  app.post("/api/webhook/stripe", async (req, res) => {
    try {
      const sig = req.headers['stripe-signature'];
      let event;

      try {
        event = stripe.webhooks.constructEvent(req.body, sig as string, process.env.STRIPE_WEBHOOK_SECRET!);
      } catch (err: any) {
        console.log(`Webhook signature verification failed.`, err.message);
        return res.status(400).send(`Webhook Error: ${err.message}`);
      }

      // Handle the event
      switch (event.type) {
        case 'payment_intent.succeeded':
          const paymentIntent = event.data.object;
          console.log('üéâ PaymentIntent erfolgreich!', paymentIntent.id);
          
          // Extrahiere Benutzer-ID aus Metadaten
          const userId = paymentIntent.metadata.userId;
          const licenseType = paymentIntent.metadata.licenseType || 'basic';
          const userEmail = paymentIntent.metadata.userEmail;
          const userName = paymentIntent.metadata.userName;
          
          if (!userId) {
            console.error('‚ùå Keine userId in PaymentIntent Metadaten gefunden');
            break;
          }
          
          try {
            // 1. AUTOMATISCHE LIZENZ-AKTIVIERUNG MIT SUBSCRIPTION-MODELL
            const subscriptionType = paymentIntent.metadata.subscriptionType || 'annual';
            const subscriptionInterval = parseInt(paymentIntent.metadata.subscriptionInterval || '12');
            
            // Lizenz-Ablaufdatum basierend auf Subscription-Typ
            const licenseExpiresAt = new Date();
            if (subscriptionType === 'monthly') {
              licenseExpiresAt.setMonth(licenseExpiresAt.getMonth() + 1); // +1 Monat
            } else {
              licenseExpiresAt.setFullYear(licenseExpiresAt.getFullYear() + 1); // +12 Monate
            }
            
            const updateData = {
              licenseType: licenseType as 'basic' | 'professional' | 'enterprise',
              paymentStatus: 'paid',
              lastPaymentDate: new Date(),
              licenseExpiresAt: licenseExpiresAt,
              subscriptionType: subscriptionType,
              subscriptionInterval: subscriptionInterval,
              subscriptionAutoRenew: subscriptionType === 'monthly', // Monthly = Auto-Renew
              stripeCustomerId: paymentIntent.customer as string || null,
              licenseStatus: 'active' as const
            };
            
            await storage.updateUser(userId, updateData);
            console.log(`‚úÖ Lizenz automatisch aktiviert f√ºr User ${userId}: ${licenseType}`);
            
            // 2. E-MAIL-BEST√ÑTIGUNG AN KUNDEN SENDEN
            if (userEmail) {
              const { emailService } = await import('./emailService');
              // const emailService = new EmailService();
              
              await emailService.sendPaymentConfirmationEmail({
                to: userEmail,
                customerName: userName || 'Kunde',
                licenseType: licenseType,
                amount: paymentIntent.amount / 100, // Convert from cents
                currency: paymentIntent.currency.toUpperCase(),
                paymentIntentId: paymentIntent.id,
                licenseExpiresAt: licenseExpiresAt
              });
              
              console.log(`üìß Zahlungsbest√§tigungs-E-Mail gesendet an: ${userEmail}`);
            }
            
            // 3. OPTIONAL: AUTOMATISCHE SFTP-EINRICHTUNG
            try {
              const { onLicenseActivated } = await import('./sftpAutoSetup');
              const sftpResult = await onLicenseActivated(userId, licenseType);
              console.log(`üîß SFTP-Setup:`, sftpResult.success ? '‚úÖ Erfolgreich' : '‚ö†Ô∏è √úbersprungen');
            } catch (sftpError) {
              console.log('‚ö†Ô∏è SFTP-Setup √ºbersprungen (nicht kritisch):', sftpError);
            }
            
          } catch (error) {
            console.error('‚ùå Fehler bei Lizenz-Aktivierung:', error);
            // Webhook sollte trotzdem 200 zur√ºckgeben, um Retry-Schleifen zu vermeiden
          }
          
          break;
          
        case 'payment_intent.payment_failed':
          const failedPayment = event.data.object;
          console.log('‚ùå PaymentIntent fehlgeschlagen:', failedPayment.id);
          // Optional: E-Mail √ºber fehlgeschlagene Zahlung senden
          break;
          
        default:
          console.log(`‚ÑπÔ∏è Unhandled event type: ${event.type}`);
      }

      res.json({ received: true });
    } catch (error: any) {
      console.error("‚ùå Webhook error:", error);
      res.status(500).json({ message: "Webhook error: " + error.message });
    }
  });

  // Get user license status
  app.get("/api/license/status", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const isExpired = user.licenseExpiresAt ? new Date() > new Date(user.licenseExpiresAt) : false;
      
      res.json({
        licenseType: user.licenseType || 'basic',
        paymentStatus: user.paymentStatus || 'unpaid',
        licenseExpiresAt: user.licenseExpiresAt,
        isExpired: isExpired,
        lastPaymentDate: user.lastPaymentDate
      });
    } catch (error: any) {
      console.error("License status error:", error);
      res.status(500).json({ 
        message: "Error fetching license status: " + error.message 
      });
    }
  });

  // Customer contacts endpoints
  app.get("/api/customers/:id/contacts", isAuthenticated, async (req: any, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const contacts = await storage.getCustomerContacts(customerId);
      res.json(contacts);
    } catch (error) {
      console.error("Error fetching customer contacts:", error);
      res.status(500).json({ message: "Failed to fetch customer contacts" });
    }
  });

  app.post("/api/customers/:id/contacts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role === "user") {
        return res.status(403).json({ message: "Sie haben keine ausreichende Berechtigung, bitte erstellen Sie ein Ticket" });
      }
      
      const customerId = parseInt(req.params.id);
      const contactData = { ...req.body, customerId };
      const newContact = await storage.createCustomerContact(contactData);
      res.status(201).json(newContact);
    } catch (error) {
      console.error("Error creating customer contact:", error);
      res.status(500).json({ message: "Failed to create customer contact" });
    }
  });

  app.put("/api/customers/:customerId/contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const contactId = parseInt(req.params.id);
      const updatedContact = await storage.updateCustomerContact(contactId, req.body);
      res.json(updatedContact);
    } catch (error) {
      console.error("Error updating customer contact:", error);
      res.status(500).json({ message: "Failed to update customer contact" });
    }
  });

  app.delete("/api/customers/:customerId/contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const contactId = parseInt(req.params.id);
      await storage.deleteCustomerContact(contactId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting customer contact:", error);
      res.status(500).json({ message: "Failed to delete customer contact" });
    }
  });

  // Company contacts endpoints
  app.get("/api/companies/:id/contacts", isAuthenticated, async (req: any, res) => {
    try {
      const companyId = parseInt(req.params.id);
      const contacts = await storage.getCompanyContacts(companyId);
      res.json(contacts);
    } catch (error) {
      console.error("Error fetching company contacts:", error);
      res.status(500).json({ message: "Failed to fetch company contacts" });
    }
  });

  app.post("/api/companies/:id/contacts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (user?.role === "user") {
        return res.status(403).json({ message: "Sie haben keine ausreichende Berechtigung, bitte erstellen Sie ein Ticket" });
      }
      
      const companyId = parseInt(req.params.id);
      const contactData = { ...req.body, companyId };
      const newContact = await storage.createCompanyContact(contactData);
      res.status(201).json(newContact);
    } catch (error) {
      console.error("Error creating company contact:", error);
      res.status(500).json({ message: "Failed to create company contact" });
    }
  });

  app.put("/api/company-contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const contactId = parseInt(req.params.id);
      const updatedContact = await storage.updateCompanyContact(contactId, req.body);
      res.json(updatedContact);
    } catch (error) {
      console.error("Error updating company contact:", error);
      res.status(500).json({ message: "Failed to update company contact" });
    }
  });

  app.delete("/api/company-contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const contactId = parseInt(req.params.id);
      await storage.deleteCompanyContact(contactId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting company contact:", error);
      res.status(500).json({ message: "Failed to delete company contact" });
    }
  });

  // Serve static documentation files
  app.get('/docs/:filename', async (req, res) => {
    try {
      const { filename } = req.params;
      const { readFile, access } = await import('fs/promises');
      const { join } = await import('path');
      
      // Security: Only allow specific markdown files
      const allowedFiles = [
        'PWA-INSTALLATION-ANLEITUNG.md',
        'README.md', 
        'README_AKTUELL_2025.md',
        'GITHUB-UPLOAD-ANLEITUNG.md'
      ];
      
      if (!allowedFiles.includes(filename)) {
        return res.status(404).json({ message: 'File not found' });
      }
      
      const filePath = join(process.cwd(), filename);
      
      try {
        await access(filePath);
      } catch {
        return res.status(404).json({ message: 'File not found' });
      }
      
      const content = await readFile(filePath, 'utf8');
      
      // Set content type for markdown
      res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
      res.setHeader('Content-Disposition', `inline; filename="${filename}"`);
      res.send(content);
    } catch (error) {
      console.error('Error serving documentation file:', error);
      res.status(500).json({ message: 'Error serving file' });
    }
  });

  // Storage-Statistiken API
  app.get('/api/storage/stats', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const attachments = await storage.getAttachments(userId);
      
      const stats = {
        totalFiles: attachments.length,
        totalSize: attachments.reduce((sum: number, att: any) => sum + (att.fileSize || 0), 0),
        filesByType: {
          images: attachments.filter((att: any) => att.mimeType?.startsWith('image/')).length,
          documents: attachments.filter((att: any) => att.mimeType?.includes('pdf') || att.mimeType?.includes('document')).length,
          audio: attachments.filter((att: any) => att.mimeType?.startsWith('audio/')).length,
          archives: attachments.filter((att: any) => att.mimeType?.includes('zip') || att.mimeType?.includes('rar')).length,
          others: attachments.filter((att: any) => {
            const mime = att.mimeType || '';
            return !mime.startsWith('image/') && !mime.includes('pdf') && !mime.includes('document') && !mime.startsWith('audio/') && !mime.includes('zip') && !mime.includes('rar');
          }).length
        },
        sizeByType: {
          images: attachments.filter((att: any) => att.mimeType?.startsWith('image/')).reduce((sum: number, att: any) => sum + (att.fileSize || 0), 0),
          documents: attachments.filter((att: any) => att.mimeType?.includes('pdf') || att.mimeType?.includes('document')).reduce((sum: number, att: any) => sum + (att.fileSize || 0), 0),
          audio: attachments.filter((att: any) => att.mimeType?.startsWith('audio/')).reduce((sum: number, att: any) => sum + (att.fileSize || 0), 0),
          archives: attachments.filter((att: any) => att.mimeType?.includes('zip') || att.mimeType?.includes('rar')).reduce((sum: number, att: any) => sum + (att.fileSize || 0), 0),
          others: attachments.filter((att: any) => {
            const mime = att.mimeType || '';
            return !mime.startsWith('image/') && !mime.includes('pdf') && !mime.includes('document') && !mime.startsWith('audio/') && !mime.includes('zip') && !mime.includes('rar');
          }).reduce((sum: number, att: any) => sum + (att.fileSize || 0), 0)
        }
      };
      
      res.json(stats);
    } catch (error) {
      console.error('Storage stats error:', error);
      res.status(500).json({ message: 'Failed to get storage statistics' });
    }
  });

  console.log('üîí Smart security middleware is active - public routes excluded, all others protected');

  // Trial Notification APIs
  app.get('/api/admin/trial-notifications', isAuthenticated, requireAdmin, async (req: any, res) => {
    try {
      const { trialNotificationService } = await import('./trialNotificationService');
      const notifications = await trialNotificationService.getNotificationHistory();
      const stats = await storage.getTrialNotificationStats();
      
      res.json({
        notifications,
        stats,
        success: true
      });
    } catch (error) {
      console.error('‚ùå Error fetching trial notifications:', error);
      res.status(500).json({ message: 'Failed to fetch trial notifications' });
    }
  });

  app.post('/api/admin/trial-notifications/check', isAuthenticated, requireAdmin, async (req: any, res) => {
    try {
      const { trialNotificationService } = await import('./trialNotificationService');
      const result = await trialNotificationService.checkAndSendNotifications();
      
      res.json({
        message: 'Trial notification check completed',
        result,
        success: true
      });
    } catch (error) {
      console.error('‚ùå Error running trial notification check:', error);
      res.status(500).json({ message: 'Failed to run trial notification check' });
    }
  });

  app.get('/api/user/trial-notifications', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { trialNotificationService } = await import('./trialNotificationService');
      const notifications = await trialNotificationService.getNotificationHistory(userId);
      
      res.json({
        notifications,
        success: true
      });
    } catch (error) {
      console.error('‚ùå Error fetching user trial notifications:', error);
      res.status(500).json({ message: 'Failed to fetch notifications' });
    }
  });

  app.get('/api/user/trial-status', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }
      
      const isTrialUser = user.licenseType === 'trial';
      const trialEndDate = user.trialEndDate;
      const licenseStatus = user.licenseStatus || 'active';
      
      let daysRemaining = 0;
      if (isTrialUser && trialEndDate) {
        const endDate = new Date(trialEndDate);
        const now = new Date();
        daysRemaining = Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      }
      
      // Check if user has trial notifications
      const { trialNotificationService } = await import('./trialNotificationService');
      const notifications = await trialNotificationService.getNotificationHistory(userId);
      const hasTrialNotifications = notifications.length > 0;
      const notificationCount = notifications.filter((n: any) => n.status === 'sent').length;
      
      res.json({
        isTrialUser,
        trialEndDate,
        daysRemaining: Math.max(0, daysRemaining),
        hasTrialNotifications,
        notificationCount,
        licenseStatus,
        success: true
      });
    } catch (error) {
      console.error('‚ùå Error fetching trial status:', error);
      res.status(500).json({ message: 'Failed to fetch trial status' });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
